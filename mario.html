<!DOCTYPE html>
<html>
    <head>
        <style>
            #body{
                height: 100%;
                margin: 0px;
            }
            #up{
	            position:absolute;
	            left:150px;
	            top: 310px;
	
            }
            #left{
	            position: absolute;
	            left: 100px;
	            top: 330px;
            }
            #right{
	            position: absolute;
	            left: 200px;
	            top: 330px;
            }
            #down{
	        position:absolute;
	        left:150px;
	        top: 340px;
            }
#enemy{
    position: absolute;
    left:300px;
    top:300px;
    height: 114px;
    width: 240px;
}
#mario{
    position: absolute;
    left: 0;
    top: 0;
    height: 78px;
    width: 135px;
    
    
}
#devCanvas{
    position: absolute;
 
    width: 100%;
    height: 100%;
   
    
}


#graphicCanvas{
    position: absolute;
 
    width: 100%;
    height: 100%;
   
    
}
    


#enemyProjectile1{
/*visibility: hidden;*/
position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
 
}
#enemyProjectile2{
    /*visibility: hidden;*/
    position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}
#enemyProjectile3{
   /*visibility: hidden;*/
   position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}
#enemyProjectile4{
 /*visibility: hidden;*/
 position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}


        </style>
        <script>


//this makes the js load after the html to prevent errors from being thrown up about event lister
var projTerval;
document.addEventListener("DOMContentLoaded", () => {
    //canvas
    const canvas = document.getElementById("devCanvas")
    //context of canvas
    const ctx = canvas.getContext("2d")
    const graphic = document.getElementById("graphicCanvas")
    const gCtx = graphic.getContext("2d")
    //interval to change the canvas resolution when the window is resized
    
        
   
     document.addEventListener("mousemove", function(event){
        mouseX = event.clientX;

mouseY = event.clientY;
//console.log(mouseX)
    

     lol=true
          }, 10)
          var canvasResize= setInterval(function(){
            canvas.width=document.body.clientWidth
     canvas.height=window.innerHeight
          }, 10)
          //used as an interval for visual representation of hitbox
          var reDraw;
         
          
    
      
        
        //top paragraph
    var xPara = document.getElementById("mousex");
    //bottom paragraph
var yPara = document.getElementById("mousey");
//enemy projectiles
var enemyProjectile1=document.getElementById("enemyProjectile1")
var enemyProjectile2 =  document.getElementById("enemyProjectile2")
var enemyProjectile3= document.getElementById("enemyProjectile3")
var enemyProjectile4 =  document.getElementById("enemyProjectile4")
//enemy
var enemy=document.getElementById("enemy")
//mario image
var mario = document.getElementById("mario");
//up button(NEED TO CHANGE TO KEYS)
var up = document.getElementById("up");
//down button
var down = document.getElementById("down");
//right button
var right = document.getElementById("right");
//left button
var left = document.getElementById("left");
//used to store attributes of the mouse
var mouseX;
var mouseY;
//used to store mouse angle relative to person
var mouseAngle;
//used later when calculating angles - had to be global
var width;
var height;
//attributes of main character
var marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
var marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
var marioHeight = mario.clientHeight
var marioWidth = mario.clientWidth
//used to alter the position of mario within move_m()

//interval for moving mario 
var work;
//attaches button to mario
//converts radians to degrees
function radiansToDegrees(radians){
  var pi = Math.PI;
  return radians * (180/pi);
}

class GameSprite{
    constructor(health, name, damage, damageClass,damageImmunityStore, damageImmunityToggle,damageImmunityTime,  ...allArr){
        this.health=health
        this.name=name
        this.damage=damage
        this.damageClass=damageClass
        this.damageImmunityStore=damageImmunityStore
        this.damageImmunityToggle=damageImmunityToggle
        this.shotDelayToggle=false
        this.allArr=allArr
        this.intervalCleared=false
        this.gunPoints=allArr[0]
    }
    kill(afterTime, img, killX, obj ){
        setTimeout(function(){
            
            
            obj.hitbox.endMovement()
            
                obj.hitbox.pointChange(obj.hitbox.points, killX, 0)
                obj.hitbox.movement(obj.hitbox.points, 1)
                eval(img).style.left=killX+"px"
         
        }, afterTime)
    }
    healthChange( sprite, change,  killX, obj){
        sprite.health+=change

        if (sprite.health<=0){
         
            sprite.kill(20, sprite.name, killX, obj)   
        }
            
        
    }
    damageReceiver(obj, damagerSprite, damageeSprite, killXer, killXee ){
        
       if(damagerSprite.damageImmunityToggle==true){
       if(damagerSprite.damageImmunityStore==false){
       
        damagerSprite.healthChange( damagerSprite, damageeSprite.damage, killXer, obj)
        damagerSprite.damageImmunityStore=true
        setTimeout(function(){
            damagerSprite.damageImmunityStore=false
        },damagerSprite.damageImmunityTime )
       }
    }else{
        damagerSprite.healthChange( damagerSprite, damageeSprite.damage,  killXer, obj)
    }
        if(damageeSprite.damageImmunityToggle==true){
       if(damageeSprite.damageImmunityStore==false){
        damageeSprite.healthChange( damageeSprite, damagerSprite.damage,  killXee, obj)
        damageeSprite.damageImmunityStore=true
        setTimeout(function(){
            damageeSprite.damageImmunityStore=false
        },damageeSprite.damageImmunityTime )
       }  
    }else{

    
        damageeSprite.healthChange( damageeSprite, damagerSprite.damage,  killXee, obj)
    }  

        
    }
    respawn(returnX, returnY, hidden, obj){
      var yDiff=returnY-obj.hitbox.points[1]
      var xDiff=returnX-obj.hitbox.points[0]
      
        eval(obj.gamesprite.name).style.left=returnX+"px"
        eval(obj.gamesprite.name).style.top=returnY+"px"
        obj.hitbox.endMovement()
        obj.hitbox.pointChange(obj.hitbox.points, xDiff, yDiff)
        if(hidden==true){
            obj.hitbox.endMovement()
            eval(obj.gamesprite.name).style.visibility="hidden" 
        }
        

    }

    shoot(projObj, gunX, gunY, targetX,targetY,  shotDelayToggleString, shotDelay,movementCount){
        if (eval(shotDelayToggleString)==false){
            
        projObj.gamesprite.respawn(gunX, gunY, false, projObj)
        var xTravel = targetX-gunX
        var yTravel = targetY-gunY 
        var iterationX = xTravel/movementCount
        var iterationY = yTravel/movementCount
        while(iterationX>5||iterationY>5){
            iterationX/=2
            iterationY/=2
        }
         projTerval = setInterval(function(){
            projObj.hitbox.endMovement()
            projObj.hitbox.pointChange(projObj.hitbox.points, iterationX, iterationY)
            projObj.hitbox.movement(projObj.hitbox.points, 1)
            eval(projObj.gamesprite.name).style.left=(Number(eval(projObj.gamesprite.name).style.left.substring(0, eval(projObj.gamesprite.name).style.left.length-2))+iterationX)+"px"
            eval(projObj.gamesprite.name).style.top=(Number(eval(projObj.gamesprite.name).style.top.substring(0, eval(projObj.gamesprite.name).style.top.length-2))+iterationY)+"px"
            
        }, 10)
        setTimeout(function(){
            clearInterval(projTerval)
        }, movementCount*10)

        eval(shotDelayToggleString+"="+true)
    }else{
        
        setTimeout(function(){
          eval(shotDelayToggleString+"="+false)
            eval(shotDelayToggleString+"="+false)
        }, shotDelay)
      
    }

}
    }

//hitbox creator - also used to log collisions          
class Hitbox{
    //parameters: x and y of object you create hitbox for
    //multistring is a 2d array - you need to pas multiple arrays into this function. 
    constructor(  ...multiArr){
        
        
        this.points=multiArr[0];
        this.horizontalTrue=multiArr[1]
        this.aboveBelow=multiArr[2]
       
       
       
    }
    //used to move and redraw the hitbox - also changes the points array
        
        movement(points, lineWidth){
       //used to temporarily store the x and y of a given point
           
        var xcoord;
        var ycoord;
        //used to check whether or not the part of the points array   you are iterating over is x or why
        var hasX=false;
       
        //interval to repeatedly redraw the hitbox
        reDraw=setInterval(function(){
           
            ctx.beginPath();
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = lineWidth;
        ctx.moveTo(points[0],points[1]);
       
      
        for (var i=0;i<points.length;i++){
           
           
            

            if (hasX==false){
                xcoord=points[i]
               
               
                hasX=true
            }else{
                ycoord=points[i]
                
                hasX=false
                
               
                ctx.lineTo(xcoord, ycoord)
                   
            }
            //console.log(xcoord+", "+ycoord)
            
        
        
    }
        
        ctx.stroke();}, 1)    
    
}
    endMovement(){
        clearInterval(reDraw)
        
    }

pointChange( points, x, y){
    
        var newX=true
       
   
        for( var j=0;j<points.length;j++){
           
            if(newX==true){
                
                points[j]+=x
                
                newX=false
            }else{
           
                points[j]+=y
                newX=true
            
            }   
            
            }   
      
        
        
    }
    
collisionDetect(points, checkingX, checkingY, horizontalTrue, aboveBelow){
   
    var newX = true
    var firstPointCounter = true
    var point1X;
    var point1Y;
    var point2X;
    var point2Y;
    var gradient;
    var yIntercept;
    var lines = []
    var fitsAllCriteria  = true;
var lineCount = (points.length-1)/2

for( var k=0;k<points.length;k++){
    
            if(newX==true){
             if (firstPointCounter==true){
                point1X = points[k]
                
             }else{
                point2X = points[k]
                
             }  
          
               
                newX=false
            }else{
                if (firstPointCounter==true){
                    firstPointCounter = false
                point1Y = points[k]
             }else{
                point2Y = points[k]
                firstPointCounter = true
             }  
                newX=true
                
            }  
            gradient = (point2Y-point1Y)/(point2X-point1X)
            yIntercept = point1Y-(gradient*point1X)
            if(k>2&&(k+1)%2==0){
            function stores(gradient, yIntercept, point1X, point1Y, point2X, point2Y){
                this.gradient=gradient
                this.yIntercept=yIntercept
                this.point1X=point1X
                this.point1Y=point1Y
                this.point2X=point2X
                this.point2Y=point2Y
            }
            lines.push(new stores(gradient, yIntercept, point1X, point1Y,point2X,point2Y))
            
            
           
        }
        
        
            } 
              
            for(var l=0; l<horizontalTrue.length; l++){
                
                
                if (horizontalTrue[l]==2){
                   
                    if(aboveBelow[l]==true){
                        
                        if(checkingY<=points[2*l]){

                        } else{
                   
                            fitsAllCriteria=false

                        }
                    }else{
                      
                        if(checkingY>=points[2*l]){
                            
                        }else{
                           
                            fitsAllCriteria=false
                        }
                      }
                }else if(horizontalTrue[l]==1){
             
                
                    if(aboveBelow[l]==true){
          
                        if(checkingX<=points[2*l]){
                            
                        }else{
                             
                            fitsAllCriteria=false
                        }
                    }else{
                     
                        
                        if(checkingY>=points[2*l]){

                        } else{
                        
                            fitsAllCriteria=false
                        }

                    }
                }else{
                if (!(Math.min(lines[l].point1X, point2X, checkingX)!=checkingX&&Math.max(lines[l].point1X, point2X, checkingX)!=checkingX)){
                
                    if(aboveBelow[l]==true){
                        
                            if(checkingY<=(lines[l].gradient*checkingX)+lines[l].yIntercept){

                            }else{
                               
                            fitsAllCriteria=false
                        }
                    }else{
                       

                        if(checkingY>=((lines[l].gradient*checkingX)+lines[l].yIntercept)){
                                
                            }else{
                                 
                                 
                            fitsAllCriteria=false
                            
                            
                        }
                    
                    
                }
            }else{}
                }
            
            }  
            return fitsAllCriteria  
}



    
    
}
class gameObj{
    constructor(hitbox, gamesprite){
        this.hitbox=hitbox
        this.gamesprite=gamesprite
        
    }
}

  var enemyStyle = getComputedStyle(enemy)
  var marioStyle = getComputedStyle(mario)
var enemyProjStyles = [getComputedStyle(enemyProjectile1), getComputedStyle(enemyProjectile2), getComputedStyle(enemyProjectile3), getComputedStyle(enemyProjectile4)]
enemy.style.left=enemyStyle.getPropertyValue("left")
enemy.style.top=enemyStyle.getPropertyValue("top")
mario.style.left = marioStyle.getPropertyValue("left")
mario.style.top = marioStyle.getPropertyValue("top")
    for (var m=0;m<enemyProjStyles.length;m++){
        eval("enemyProjectile"+(m+1)).style.left=enemyProjStyles[m].getPropertyValue("left")
        eval("enemyProjectile"+(m+1)).style.top=enemyProjStyles[m].getPropertyValue("top")
    }

//x and ys of main character
var marioPosArr = [19, 23,67,0,123,24,138, 46,120,77,67,67,23,80,-2, 46,  19,23]
//orientation of the lines of the hitbox, 0=diagonal, 1=vertical, 2=horizontal
var marioOrientationArr = [ 0,0 , 0, 0,0, 0 , 0,0 ]
//defines where a point must be to be within the hitbox, true is above a given line, false is below, (left/right respectively for vertical lines)
var marioContentsArr= [false, false, false, true, true, true, true, false]
var marioObj = new gameObj(new Hitbox(  ...[[...marioPosArr],[...marioOrientationArr],[...marioContentsArr]]),new GameSprite(50000, "mario", -1, 3,false,true, 250,  ...[...[71,6]]) )
x=new GameSprite()
var enemyProjectilePosArrays = [[3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0], [3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0], [3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0],[3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0]] 
var enemyProjectileOrientationArrays = [ [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0]]
var enemyProjectileContentArrays = [false, false, true, true, true, true, false, false ]
//within gameSprite, the arguments are health, name, damage, type of damage, and damage that can be received
//gameObj for declaring the hitbox, gamesprite
var enemyProjectileObj1 = new gameObj(new Hitbox(...[[...enemyProjectilePosArrays[0]],[...enemyProjectileOrientationArrays[0]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile1", -10, 0,false, false, 0,  ...[...[]]))
var enemyProjectileObj2 = new gameObj(new Hitbox( ...[[...enemyProjectilePosArrays[1]],[...enemyProjectileOrientationArrays[1]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile2" , -10, 0,false, false, 0,  ...[...[]]))
var enemyProjectileObj3 = new gameObj(new Hitbox(...[[...enemyProjectilePosArrays[2]],[...enemyProjectileOrientationArrays[2]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile3", -10, 0,false, false, 0,   ...[...[]]))
var enemyProjectileObj4 = new gameObj(new Hitbox( ...[[...enemyProjectilePosArrays[3]],[...enemyProjectileOrientationArrays[3]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile4",-10, 0,false, false, 0, ...[...[]]))

var enemyPosArr = [309, 327, 390, 321, 456, 300, 522, 321, 549,  357, 522, 393, 456, 408, 390, 396, 309, 393, 291, 357, 309, 327]
var enemyOrientationArr = [0,0,0,0,0,0,0,0,0,  0]
var enemyContentsArr = [false, false, false, false, true, true, true, true, true, false]
var enemyObj = new gameObj(new Hitbox(...[[...enemyPosArr], [...enemyOrientationArr], [...enemyContentsArr]]), new GameSprite(100, "enemy", -1, 2, false, true, 250, ...[...[325, 333, 325, 384]]))


//starting all hitboxes
enemyProjectileObj1.hitbox.movement( enemyProjectilePosArrays[0], 1)
enemyProjectileObj2.hitbox.movement(enemyProjectilePosArrays[1], 1)
enemyProjectileObj3.hitbox.movement( enemyProjectilePosArrays[2], 1)
enemyProjectileObj4.hitbox.movement(enemyProjectilePosArrays[3], 1)

marioObj.hitbox.movement(marioObj.hitbox.points, 1)
enemyObj.hitbox.movement(enemyObj.hitbox.points, 1)
function buttonControl(freq, btn, btnstring){
    //on mouse down , runs start move
    btn.addEventListener("mousedown", startMove);
    //start move creates work interval of move_m
    function startMove(){
        marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
    

   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
 
    xPara.innerHTML = Math.floor(mouseAngle)
        work = setInterval(function(){
            move_m(btnstring)
            
         
   
}, freq);
        
    }
    //on mouse up, runs end move
    btn.addEventListener("mouseup", endMove);
    //end move clears work interval
    function endMove(){
        clearInterval(work);
        
    }
    
}

//this is where the magic happens - used to move mari

function move_m(direction){
    var changer = 0;
    switch(direction){
   //if the direction is up
   case "up":
  
       //used to decide how much the value(top or left) is being changed by
       changer = -1;
      
       //checks if it is within limits
       if (Number(mario.style.top.substring(0, mario.style.top.length - 2))<=0){
          
       }else{
           //actually changes value
           mario.style.top=Number(mario.style.top.substring(0, mario.style.top.length - 2))+changer+"px";
           marioObj.hitbox.endMovement()
           marioObj.hitbox.pointChange(marioObj.hitbox.points,0,-1)
            marioObj.hitbox.movement(marioObj.hitbox.points, 1)
            
        }
      
       break;
       //direction is down
 
       case "down":
      
       changer = 1
      
       //see above for all of these
   if (Number(mario.style.top.substring(0, mario.style.top.length - 2))>=canvas.height){
   
       }else{
           mario.style.top=Number(mario.style.top.substring(0, mario.style.top.length - 2))+changer+"px";
           marioObj.hitbox.endMovement()
           marioObj.hitbox.pointChange(marioObj.hitbox.points,0,1)
           marioObj.hitbox.movement( marioObj.hitbox.points, 1)
           
        }
      
       break;
   case "left":
  
      if (Number(mario.style.left.substring(0, mario.style.left.length - 2))<=0){
          
       }else{
           mario.style.left=Number(mario.style.left.substring(0, mario.style.left.length - 2))-1+"px";
           marioObj.hitbox.endMovement()
           
           marioObj.hitbox.pointChange(marioObj.hitbox.points,-1,0)
           marioObj.hitbox.movement( marioObj.hitbox.points, 1)
           
           
        }
      
       break;
   case"right":
   
    if (Number(mario.style.left.substring(0, mario.style.left.length - 2))>=canvas.width){
       
       }else{
           mario.style.left=Number(mario.style.left.substring(0, mario.style.left.length - 2))+1+"px";
           marioObj.hitbox.endMovement()
           marioObj.hitbox.pointChange(marioObj.hitbox.points,1,0)
           marioObj.hitbox.movement(enemyObj.hitbox.points,1)
           
       }
      
       break;
   default:
}




    
}

// (canvas.style.left)
function enemyProjMovement(number, direction){
   var changer = 0
eval("enemyProjectile"+number).style.top=Number(eval("enemyProjectile"+number).style.top.substring(0, eval("enemyProjectile"+number).style.top.length - 2))+changer+"px"

    switch(direction){
   //if the direction is up
   case "up":
  
       //used to decide how much the value(top or left) is being changed by
       changer = -1;
      
       //checks if it is within limits
       if (Number(eval("enemyProjectile"+number).style.top.substring(0, eval("enemyProjectile"+number).style.top.length - 2))<=00){
          
       }else{
           //actually changes value
           eval("enemyProjectile"+number).style.top=Number(eval("enemyProjectile"+number).style.top.substring(0, eval("enemyProjectile"+number).style.top.length - 2))+changer+"px";
           eval("enemyProjectileObj"+number).hitbox.endMovement()
          eval("enemyProjectileObj"+number).hitbox.pointChange(eval("enemyProjectileObj"+number).hitbox.points, 0, changer)
         // console.log("enemyProjectileObj"+number+" up")
          eval("enemyProjectileObj"+number).hitbox.movement(eval("enemyProjectileObj"+number).hitbox.points, 1)
            
            
        }
      
       break;
       //direction is down
 
       case "down":
      
       changer = 1
      
       //see above for all of these
   if (Number(eval("enemyProjectile"+number).style.top.substring(0, eval("enemyProjectile"+number).style.top.length - 2))>=canvas.height){
   
       }else{
           eval("enemyProjectile"+number).style.top=Number(eval("enemyProjectile"+number).style.top.substring(0, eval("enemyProjectile"+number).style.top.length - 2))+changer+"px";
           eval("enemyProjectileObj"+number).hitbox.endMovement()
          eval("enemyProjectileObj"+number).hitbox.pointChange(eval("enemyProjectileObj"+number).hitbox.points, 0, changer)
          //console.log("enemyProjectileObj"+number+" down")
          eval("enemyProjectileObj"+number).hitbox.movement(eval("enemyProjectileObj"+number).hitbox.points, 1)
            
           
        }
      
       break;
   case "left":
        changer=-1
      if (Number(eval("enemyProjectile"+number).style.left.substring(0, eval("enemyProjectile"+number).style.left.length - 2))<=0){
          
       }else{
           eval("enemyProjectile"+number).style.left=Number(eval("enemyProjectile"+number).style.left.substring(0, eval("enemyProjectile"+number).style.left.length - 2))-1+"px";
           eval("enemyProjectileObj"+number).hitbox.endMovement()
          eval("enemyProjectileObj"+number).hitbox.pointChange(eval("enemyProjectileObj"+number).hitbox.points,  changer, 0)
          //console.log("enemyProjectileObj"+number+" left")
          eval("enemyProjectileObj"+number).hitbox.movement(eval("enemyProjectileObj"+number).hitbox.points, 1)
            
           
        }
      
       break;
   case"right":
        changer=1
    if (Number(eval("enemyProjectile"+number).style.left.substring(0, eval("enemyProjectile"+number).style.left.length - 2))>=canvas.width){
        
       }else{
           eval("enemyProjectile"+number).style.left=Number(eval("enemyProjectile"+number).style.left.substring(0, eval("enemyProjectile"+number).style.left.length - 2))+1+"px";
           eval("enemyProjectileObj"+number).hitbox.endMovement()
          eval("enemyProjectileObj"+number).hitbox.pointChange(eval("enemyProjectileObj"+number).hitbox.points, changer, 0)
          //console.log("enemyProjectileObj"+number+" right")
          eval("enemyProjectileObj"+number).hitbox.movement(eval("enemyProjectileObj"+number).hitbox.points, 1)
            
       }
      
       break;
   default:
}

   }
   function enemyMovement(direction){
    var changer = 0;
    
 
    switch(direction){
   //if the direction is up
   case "up":
  
       //used to decide how much the value(top or left) is being changed by
       changer = -1;
      
       //checks if it is within limits
       if (Number(enemy.style.top.substring(0, enemy.style.top.length - 2))<=0){
     
       }else{
           //actually changes value
           enemy.style.top=Number(enemy.style.top.substring(0, enemy.style.top.length - 2))+changer+"px";
           enemyObj.hitbox.endMovement()
           enemyObj.hitbox.pointChange(enemyObj.hitbox.points,0,-1)
            enemyObj.hitbox.movement(enemyObj.hitbox.points, 1)
              
        }
      
       break;
       //direction is down
 
       case "down":
      
       changer = 1
      
       //see above for all of these
   if (Number(enemy.style.top.substring(0, enemy.style.top.length - 2))>=canvas.height){
   
       }else{
           enemy.style.top=Number(enemy.style.top.substring(0, enemy.style.top.length - 2))+changer+"px";
           enemyObj.hitbox.endMovement()
           enemyObj.hitbox.pointChange(enemyObj.hitbox.points,0,1)
           enemyObj.hitbox.movement( enemyObj.hitbox.points, 1)
             
        }
      
       break;
   case "left":
  
      if (Number(enemy.style.left.substring(0, enemy.style.left.length - 2))<=0){
          
       }else{
           enemy.style.left=Number(enemy.style.left.substring(0, enemy.style.left.length - 2))-1+"px";
           enemyObj.hitbox.endMovement()
           
           enemyObj.hitbox.pointChange(enemyObj.hitbox.points,-1,0)
           enemyObj.hitbox.movement( enemyObj.hitbox.points, 1)
             
           
        }
      
       break;
   case"right":
   
    if (Number(enemy.style.left.substring(0, enemy.style.left.length - 2))>=canvas.width){
       
       }else{
           enemy.style.left=Number(enemy.style.left.substring(0, enemy.style.left.length - 2))+1+"px";
           
           enemyObj.hitbox.endMovement()
           enemyObj.hitbox.pointChange(enemyObj.hitbox.points,1,0)
           enemyObj.hitbox.movement(enemyObj.hitbox.points, 1)
             
           
       }
      
       break;
   default:
}
   }

var worker;
//used to check whether the key has already been pressed, to prevent the function from creating infinite intervals
var keyDownCheck;
//binding the keyboard rather than the buttons for movement
function keyControl(freq){
    //when any key is pressed down
    document.addEventListener("keydown", function(event) {
        //checks if keydown has already been called, without a keyup inbetween
        if (keyDownCheck==false){
             marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
             marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
             
            
        //checks the keycode of the pressed key
        switch (event.keyCode){
            
            case 87: 
            //w to move up
            worker = setInterval(function(){move_m("up")
       
        }, freq);
            
            
            break;
            case 83: 
            //s to move down
           worker = setInterval(function(){move_m("down")
           
         
    }, freq);
            break;
            case 68: 
            //d to move right
            worker = setInterval(function(){move_m("right")
                    
        }, freq);
            
            
            break;
            case 65: 
            //a to move left
            
            worker = setInterval(function(){move_m("left")}, freq);
            break;
            default:
                
        }
    }
    //shows that key has been pressed down
    keyDownCheck=true;
    });
    
    

    document.addEventListener("keyup", function(event){
        //stops movement
        clearInterval(worker);
        //shows that key has been released
        keyDownCheck = false;
    });
}
//actually runs the function
keyControl(10);

//associates function with each button
//down
buttonControl(10, down, "down");
//left
buttonControl(10, left, "left");
//right
buttonControl(10, right, "right");
//up
buttonControl(10, up, "up");
function angleCalc(personX, personY, objX, objY){
    
     width = personX-objX;
 
     height = personY-objY;
    var rawAngle = radiansToDegrees(Math.atan(height/width));
    if(width<0){
        rawAngle+=180
    }else if(height<0){
        rawAngle+=360

    }else if(height<0&&width<0){
        rawAngle+=270
    }
    return rawAngle

}
document.addEventListener("mousemove",function(event){
     marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
   
   
   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
   
    
    xPara.innerHTML = mouseX
    yPara.innerHTML = mouseY
});

document.addEventListener("keydown", function(){
    marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
    

   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
   
   

});

function hitboxCollision(collider, collidee, colliderPointsArr, collideePointsArr){
        var xArr = []
        var yArr = []
        var borderArr = []
        var colliderTrue;
        
      var collideeTrue;
      var collision
     
        for(var n=0;n<collideePointsArr.length;n++){
            if(n%2==0){
                xArr.push(collideePointsArr[n])
                
            }else{
                yArr.push(collideePointsArr[n])
                
            }
        }
    
        var Xminimum = Math.min.apply(Math,xArr)
        var Yminimum = Math.min.apply(Math,yArr)
        var Xmaximum = Math.max.apply(Math,xArr)
        var Ymaximum = Math.max.apply(Math,yArr)
       borderArr.push(Xminimum, Yminimum, Xmaximum, Ymaximum)
      
      for(var p=Yminimum;p<=Ymaximum;p++){
        for(var q = Xminimum; q<=Xmaximum;q++){
                 collideeTrue = collidee.collisionDetect(collidee.points, q, p, collidee.horizontalTrue, collidee.aboveBelow) 
                 colliderTrue = collider.collisionDetect(collider.points, q, p, collider.horizontalTrue, collider.aboveBelow)
               
                
               
                 if(collideeTrue==true&&colliderTrue==true){
                    collision=true
                   
                 }
                 
        }
       }
       
       if(collision!=true){
        collision=false
       }
      return collision
    }


   

/*
var marioDamage = setInterval(function(){
    collide = hitboxCollision( marioObj.hitbox,enemyProjectileObj1.hitbox, marioObj.hitbox.points,enemyProjectileObj1.hitbox.points, )
    if(collide==true){
        marioObj.gamesprite.damageReceiver(enemyProjectileObj1, marioObj.gamesprite, enemyProjectileObj1.gamesprite, 50000, 50000 )
      
    }

  

}, 200)
*/
var aimingRadicalInterval;
var aimRadicalHitbox;
var finalY;
var aimYIntercept;
var aimGradient;
var mouseDelay;
var mouseTrue=false;
function aimingRadical(gunX, gunY){
    

  
     
   
    aimRadicalHitbox = new Hitbox(...[[eval(gunX), eval(gunY), mouseX, mouseY], ...[0], ...[]])
    
     aimingRadicalInterval = setInterval(function(){
        if((mouseY-eval(gunY))/(mouseX-eval(gunX))!=Infinity){
        aimGradient = (mouseY-eval(gunY))/(mouseX-eval(gunX))
        }
        
aimYIntercept = mouseY-(aimGradient*mouseX)

 finalY=aimGradient*document.body.clientWidth+aimYIntercept
        aimRadicalHitbox.endMovement()
      
        aimRadicalHitbox.points[0]=eval(gunX)
        aimRadicalHitbox.points[1]=eval(gunY)
        aimRadicalHitbox.points[2]=mouseX
        aimRadicalHitbox.points[3]=mouseY
       
        aimRadicalHitbox.movement(aimRadicalHitbox.points, 6)
        

        
     }, 20)
    
     document.addEventListener("mousedown", function(){
        //var a =performance.now()
        
if (mouseX>eval(gunX)&&mouseX>0&&mouseTrue==false){
marioObj.gamesprite.shoot(enemyProjectileObj2, eval(gunX), eval(gunY),  document.body.clientWidth+240,finalY,"marioObj.gamesprite.shotDelayToggle", 750,  500)
mouseTrue=true 
console.log(document.body.clientWidth)
setTimeout( function(){mouseTrue=false}, 500)
}
    
    
//var b=performance.now()
//console.log(b-a)
})

     
    
}

setTimeout(function(){
    aimingRadical("marioObj.hitbox.points[2]", "marioObj.hitbox.points[3]")
    
}, 2000)
function enemyAI(difficulty   ){

}



//END OF JS CODE HERE  
});

 

    

        </script>
    </head>
    <body id="body">
        <img src = "https://i.ibb.co/3cdyx1Y/d-sub-pixilart-3.jpg" alt = "its a me a" id  =  "mario">
        <img src="https://i.ibb.co/M5m4Jpn/pixilart-drawing-1.png" alt="enemy" id="enemy">
      
       <canvas id="devCanvas"style = "   left: 0px; top: 0px;"  ></canvas>
      
<p>Use WASD or the buttons to move</p>
<p id="mousex">hello</p>
<p id = "mousey">l</p>

<img  id = "enemyProjectile1"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile2"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile3"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile4"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<button id="up">up</button>
<button id = "down">down</button>
<button id = "right">right</button>
<button id ="left">left</button>
<canvas id="graphicCanvas" ></canvas>

    </body>

</html>