<!DOCTYPE html>
<html>
    <head>
        <style>
            /*l*/
            html, body {margin: 0; height: 100%; overflow: hidden}
            #body{
                height: 100%;
                margin: 0px;
            }
            #up{
	            position:absolute;
	            left:150px;
	            top: 310px;
	
            }
            #left{
	            position: absolute;
	            left: 100px;
	            top: 330px;
            }
            #right{
	            position: absolute;
	            left: 200px;
	            top: 330px;
            }
            #down{
	        position:absolute;
	        left:150px;
	        top: 340px;
            }
#enemy{
    position: absolute;
    left:300px;
    top:300px;
    height: 114px;
    width: 240px;
}
#mario{
    position: absolute;
    left: 0;
    top: 0;
    height: 78px;
    width: 135px;
    
    
}
#devCanvas{
    position: absolute;
 z-index:1;
    width: 100%;
    height: 100%;
   
    
}


#graphicCanvas{
    position: absolute;
    z-index:-1;
    top:0;
    left:0;
    width: 100%;
    height: 100%;
   
    
}
    


#enemyProjectile1{
/*visibility: hidden;*/
position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
 
}
#enemyProjectile2{
    /*visibility: hidden;*/
    position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}
#enemyProjectile3{
   /*visibility: hidden;*/
   position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}
#enemyProjectile4{
 /*visibility: hidden;*/
 position: absolute;
    height: 16px;
    width: 16px;
    left: 0px; 
    top: 1px;
}
#start{
    z-index:1;
}
#end{
    z-index:1;
    display:none;
}


        </style>
        <script>


//this makes the js load after the html to prevent errors from being thrown up about event lister
var projTerval = []
var projIteration = -1;
document.addEventListener("DOMContentLoaded", () => {
   
   
    var isMobile = false; //initiate as false
// device detection
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
    isMobile = true;
}
    //canvas
    const canvas = document.getElementById("devCanvas")
    //context of canvas
    const ctx = canvas.getContext("2d")
    //graphic canvas used for aiming radicals/tutorial
    const graphic = document.getElementById("graphicCanvas")
    const gCtx = graphic.getContext("2d")
    //interval to change the canvas resolution when the window is resized
        //yall shouldn't resize the page abeg
        var graphicStyle = getComputedStyle(graphic)
        graphic.width=document.body.clientWidth
        graphic.height=window.innerHeight
        graphic.style.width=document.body.clientWidth
        graphic.style.height=window.innerHeight
        graphic.style.width=graphicStyle.getPropertyValue("width")
        graphic.style.height=graphicStyle.getPropertyValue("height")
      
    var canvasStyle=getComputedStyle(canvas)
        canvas.width=document.body.clientWidth
        canvas.height=window.innerHeight
        canvas.style.width=document.body.clientWidth
        canvas.style.height=window.innerHeight
        canvas.style.width=canvasStyle.getPropertyValue("width")
        canvas.style.height=canvasStyle.getPropertyValue("height")
   //mouseX and mouseY used later in the code
   var mouseEnd;
   setInterval(function(){
    mouseEnd = true
   }, 20)
     document.addEventListener("mousemove", function(event){
  
       
        mouseX = event.clientX;

mouseY = event.clientY;
////console.log(mouseX)
        mouseEnd=false

     lol=true

          })
     
          var graphicClear= setInterval(function(){
            //dev canvas is constantly resizing bc im lazy

      
            gCtx.clearRect(0,0, graphic.width, graphic.height)
 //console.log(canvas.height)
     
          }, 2500)
         var devClear = setInterval(function(){
             ctx.clearRect(0,0,canvas.width, canvas.height)
         }, 10)
          
          //used as an interval for visual representation of hitbox
          var reDraw;
         
          
    
      
        //importing html DOM elements
        //top paragraph
    var xPara = document.getElementById("mousex");
    //bottom paragraph
var yPara = document.getElementById("mousey");
//enemy projectiles img
var enemyProjectile1=document.getElementById("enemyProjectile1")
var enemyProjectile2 =  document.getElementById("enemyProjectile2")
var enemyProjectile3= document.getElementById("enemyProjectile3")
var enemyProjectile4 =  document.getElementById("enemyProjectile4")
//enemy
var enemy=document.getElementById("enemy")
//mario image
var mario = document.getElementById("mario");
//up button(NEED TO CHANGE TO KEYS)
var up = document.getElementById("up");
//down button
var down = document.getElementById("down");
//right button
var right = document.getElementById("right");
//left button
var left = document.getElementById("left");
//used to store attributes of the mouse
var mouseX;
var mouseY;
//used to store mouse angle relative to person
var mouseAngle;
//used later when calculating angles - had to be global
var width;
var height;
//attributes of main character
var marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
var marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
var marioHeight = mario.clientHeight
var marioWidth = mario.clientWidth
//used to alter the position of mario within move_m()

//interval for moving mario 
var work;

//converts radians to degrees
function radiansToDegrees(radians){
  var pi = Math.PI;
  return radians * (180/pi);
}
//used to store the random direction and distance for the enemy movement
var directionRand;
var distanceRand;
//used to control the randomly generated enemy movement
class enemyAI{
   constructor(difficulty){
    this.directionRand=0
    this.distanceRand=0
    this.difficulty=difficulty
   }
   randomMovement(directionRandString, distanceRandString, difficulty){
    var genInterval=difficulty
    genInterval+=1
    genInterval*=500
    var pathDir;
    var curIt=1
    var dist;
    var randInterval;
     var generator = setInterval(function(){
        endMover()
   
        directionRandString=""+Math.round(Math.random()*24)
   
        distanceRandString= ""+Math.random()*(document.body.width>window.innerHeight?document.body.width:window.innerHeight)
        
        distanceRandString=""+eval(distanceRandString)/15
        
        lifelessMover()
        
        curIt++
    }, genInterval*2)
    
    function lifelessMover(){
        
        var numberIterated=0
    
    //move based on distance and directionRand Strings
    //currently moves a total of 6 px per iteration(every 10 ms)
    //directionRandString controls number of iterations(maximum 500ms)
    //need to make this a fit-all difficulty function
   
 //forces it to be within a vertical limit
    if((enemyObj.hitbox.points[1]-150)<=0){
      
            directionRandString="11"
         
        
        
    }
    if(((enemyObj.hitbox.points[1]+150)>=window.innerHeight)){
       
            directionRandString="23"
      
     
            
           
        
       
    }
    if(((enemyObj.hitbox.points[0]+150)>=window.innerWidth)){
        directionRandString="18"
        
       
    }
    if(((enemyObj.hitbox.points[0]-150)<=0)){
        if(directionRandString>18&&directionRandString<=24){
            directionRandString=""+eval(directionRandString)-12
            
        }else if(directionRandString<=18&&directionRandString>12){
            directionRandString=""+eval(directionRandString)-6
           
        }
       
    }
        if (eval(directionRandString)<=6){
        //allows it to move up and right
        randInterval= setInterval(function(){
            
            if(numberIterated<eval(distanceRandString)){
                switch(eval(directionRandString)){
                    case 1: 
                    for (var i=0;i<5;i++){
                        enemyMovement("up")
                    }
                    enemyMovement("right")
                    case 2: 
                    for (var i=0;i<4;i++){
                        enemyMovement("up")
                    }
                    enemyMovement("right")
                    enemyMovement("right")
                    case 3: 
                    for (var i=0;i<3;i++){
                        enemyMovement("up")
                    }
                    for (var i=0;i<3;i++){
                        enemyMovement("right")
                    }
                    case 4: 
                    for (var i=0;i<2;i++){
                        enemyMovement("right")
                    }
                    for (var i=0;i<4;i++){
                        enemyMovement("right")
                    }
                    case 5: 
                    
                        enemyMovement("up")
                    
                    for (var i=0;i<5;i++){
                        enemyMovement("right")
                    }
                    case 6:
                    for (var i=0;i<6;i++){
                        enemyMovement("right")
                    } 
                    default:
                }
            }
            numberIterated+=1
        }, genInterval/16)
        }else if (eval(directionRandString)<=12){
        //allows it to move down and right
            randInterval= setInterval(function(){
            
            if(numberIterated<eval(distanceRandString)){
                switch(eval(directionRandString)){
                    case 7: 
                    for (var i=0;i<5;i++){
                        enemyMovement("right")
                    }
                    enemyMovement("down")
                    case 8: 
                    for (var i=0;i<4;i++){
                        enemyMovement("right")
                    }
                    enemyMovement("down")
                    enemyMovement("down")
                    case 9: 
                    for (var i=0;i<3;i++){
                        enemyMovement("right")
                    }
                    for (var i=0;i<3;i++){
                        enemyMovement("down")
                    }
                    case 10: 
                    for (var i=0;i<2;i++){
                        enemyMovement("right")
                    }
                    for (var i=0;i<4;i++){
                        enemyMovement("down")
                    }
                    case 11: 
                    
                        enemyMovement("right")
                    
                    for (var i=0;i<5;i++){
                        enemyMovement("down")
                    }
                    case 12:
                    for (var i=0;i<6;i++){
                        enemyMovement("right")
                    } 
                    default:
                }
            }
            numberIterated+=1
        }, genInterval/16)
        }else if (eval(directionRandString)<=18){
        //allows it to move down and left
            randInterval= setInterval(function(){
            
            if(numberIterated<eval(distanceRandString)){
                switch(eval(directionRandString)){
                    case 13: 
                    for (var i=0;i<5;i++){
                        enemyMovement("down")
                    }
                    enemyMovement("left")
                    case 14: 
                    for (var i=0;i<4;i++){
                        enemyMovement("down")
                    }
                    enemyMovement("left")
                    enemyMovement("left")
                    case 15: 
                    for (var i=0;i<3;i++){
                        enemyMovement("down")
                    }
                    for (var i=0;i<3;i++){
                        enemyMovement("left")
                    }
                    case 16: 
                    for (var i=0;i<2;i++){
                        enemyMovement("down")
                    }
                    for (var i=0;i<4;i++){
                        enemyMovement("left")
                    }
                    case 17: 
                    
                        enemyMovement("down")
                    
                    for (var i=0;i<5;i++){
                        enemyMovement("left")
                    }
                    case 18:
                    for (var i=0;i<6;i++){
                        enemyMovement("left")
                    } 
                    default:
                }
            }
            numberIterated+=1
        }, genInterval/16)
        }else if (eval(directionRandString)<=24){
        //alows it to move up and left
            randInterval= setInterval(function(){
            
            if(numberIterated<eval(distanceRandString)){
                switch(eval(directionRandString)){
                    case 19: 
                    for (var i=0;i<5;i++){
                        enemyMovement("left")
                    }
                    enemyMovement("up")
                    case 20: 
                    for (var i=0;i<4;i++){
                        enemyMovement("left")
                    }
                    enemyMovement("up")
                    enemyMovement("up")
                    case 21: 
                    for (var i=0;i<3;i++){
                        enemyMovement("left")
                    }
                    for (var i=0;i<3;i++){
                        enemyMovement("up")
                    }
                    case 22: 
                    for (var i=0;i<2;i++){
                        enemyMovement("left")
                    }
                    for (var i=0;i<4;i++){
                        enemyMovement("up")
                    }
                    case 23: 
                    
                        enemyMovement("left")
                    
                    for (var i=0;i<5;i++){
                        enemyMovement("up")
                    }
                    case 24:
                    for (var i=0;i<6;i++){
                        enemyMovement("left")
                    } 
                    default:
                }
            }
            numberIterated+=1/6
        }, genInterval/16)
        }
    }
    //stops the game lagging out from too many intervals
    function endMover(){
        clearInterval(  randInterval)
    }
    }
}
//carrys out function s such as shooting and killing things
class GameSprite{
    constructor(health, name, damage, damageClass,damageImmunityStore, damageImmunityToggle,damageImmunityTime,   ...allArr_gunPoints){
        this.health=health
        this.maxHealth=health
        this.name=name
        this.damage=damage
        this.damageClass=damageClass
        this.damageImmunityStore=damageImmunityStore
        this.damageImmunityToggle=damageImmunityToggle
        this.shotDelayToggle=false
        
        this.intervalCleared=false
        this.gunPoints=allArr_gunPoints[0]
    }
    //moves the img and hitbox to a given place(very var X)
    kill(afterTime, img, killX, obj ){

        setTimeout(function(){
            
            
            obj.hitbox.endMovement(obj)
            
                obj.hitbox.pointChange(obj.hitbox.points, killX, 0)
                obj.hitbox.movement(obj.hitbox.points, 1, obj)
                eval(img).style.left=killX
            

        }, afterTime)
    }
    //allows the sprite's health to be changed - calls kill when necessary
    healthChange(  change,  killX, obj){
        
        obj.gamesprite.health+=change
        if(obj.gamesprite.health>obj.gamesprite.maxHealth){
            obj.gamesprite.health-=(obj.gamesprite.health-obj.gamesprite.maxHealth)
        }
        if (obj.gamesprite.health<=0){
           
            obj.gamesprite.kill(20, obj.gamesprite.name, killX, obj)   
        }
            
        
    }
    //allows you to incorporate damage immunity(if i can acc be asked)
    //damage immunity toggle asks whether damage immunity is enabled
    //damage immunity store asks whether the immunity is active
    damageReceiver(obj, damagerSprite, damageeSprite, killXer, killXee ){

       if(damagerSprite.damageImmunityToggle==true){
       if(damagerSprite.damageImmunityStore==false){
       
        damagerSprite.healthChange( damagerSprite, damageeSprite.damage, killXer, obj)
        damagerSprite.damageImmunityStore=true
        setTimeout(function(){
            damagerSprite.damageImmunityStore=false
        },damagerSprite.damageImmunityTime )
       }
    }else{
        damagerSprite.healthChange( damagerSprite, damageeSprite.damage,  killXer, obj)
    }
        if(damageeSprite.damageImmunityToggle==true){
       if(damageeSprite.damageImmunityStore==false){
        damageeSprite.healthChange( damageeSprite, damagerSprite.damage,  killXee, obj)
        damageeSprite.damageImmunityStore=true
        setTimeout(function(){
            damageeSprite.damageImmunityStore=false
        },damageeSprite.damageImmunityTime )
       }  
    }else{

    
        damageeSprite.healthChange( damageeSprite, damagerSprite.damage,  killXee, obj)
    }  

        
    }
    //returns the img and the hitbox to the specified x and y from ~50,000px
    respawn(returnX, returnY, hidden, obj,  respHealth){
      var yDiff=returnY-obj.hitbox.points[1]
      var xDiff=returnX-obj.hitbox.points[0]
      
        eval(obj.gamesprite.name).style.left=returnX+"px"
        eval(obj.gamesprite.name).style.top=returnY+"px"
        obj.hitbox.endMovement(obj)
     
        obj.hitbox.pointChange(obj.hitbox.points, xDiff, yDiff)
        obj.hitbox.movement(obj.hitbox.points, 1, obj)
     
        

    }
    //shoots the projectile from the gun X  - movement is limited to 5px in either direction
    //allows for shot delay - damage immunity kinda unnecessary now. 
    shoot(projObj, gunXString, gunYString, targetXString,targetYString,  shotDelayToggleString, shotDelay,movementCount){
        var iterationX
        var iterationY;
        clearInterval(projTerval[projIteration])

        if (eval(shotDelayToggleString)==false){
         
            intervalClearer(projIteration-2)
            intervalClearer(projIteration)
            clearInterval(projTerval[projIteration-2])
        projObj.gamesprite.respawn(eval(gunXString), eval(gunYString), false, projObj, projObj.gamesprite.maxHealth)
        
        var xTravel = eval(targetXString+"-"+gunXString)
        var yTravel = eval(targetYString+"-"+gunYString) 
        iterationX = xTravel/movementCount
       iterationY = yTravel/movementCount
       if(iterationY>0&&iterationX>0){
        while(iterationX<3.5||iterationY<3.5){
            iterationX*=1.025
            iterationY*=1.025
            movementCount/=1.025
            
        }
    }else if(iterationX>0){
        while(iterationX<3.5||iterationY>-3.5){
            iterationX*=1.025
            iterationY*=1.025
            movementCount/=1.025
            
        }
    }else if(iterationX==0&&iterationY<0){
        while(iterationY>-3.5){
            iterationX*=1.025
            iterationY*=1.025
            movementCount/=1.025
            
        }
        console.log("chargeable")
    }else if(iterationX==0&&iterationY>0){
        while(iterationY<3.5){
            iterationX*=1.025
            iterationY*=1.025
            movementCount/=1.025
            
        }
        console.log("chargeable")
    }
  
       
       
        
        projIteration++
       
         projTerval.push( 
            
            setInterval(function(){
                
              
                
            projObj.hitbox.endMovement(projObj)
            projObj.hitbox.pointChange(projObj.hitbox.points, iterationX, iterationY)
            projObj.hitbox.movement(projObj.hitbox.points, 1, projObj)
            eval(projObj.gamesprite.name).style.left=(Number(eval(projObj.gamesprite.name).style.left.substring(0, eval(projObj.gamesprite.name).style.left.length-2))+iterationX)+"px"
            eval(projObj.gamesprite.name).style.top=(Number(eval(projObj.gamesprite.name).style.top.substring(0, eval(projObj.gamesprite.name).style.top.length-2))+iterationY)+"px"
            
         
        
        }, 10)
         )
         intervalClearer(projIteration-1)
         intervalClearer(projIteration)
        function intervalClearer(num){
            
        
            
     setTimeout(function(){
            //stops tzhe projectile moving
            //problem with this timeout - not clearing as expected
            clearInterval(projTerval[num])
           
            
       projObj.gamesprite.kill(0, eval(projObj.gamesprite.name), 50000, projObj)
        }, (movementCount*20))
        }

        eval(shotDelayToggleString+"="+true)
        setTimeout(function(){
          eval(shotDelayToggleString+"="+false)
            eval(shotDelayToggleString+"="+false)
            
         
        }, shotDelay)
    }else{
        
       
      
    }

}
    }

//hitbox creator - also used to log collisions          
class Hitbox{
    //parameters: x and y of object you create hitbox for
    //multistring is a 2d array - you need to pas multiple arrays into this function. 
    constructor(   ...multiArr_points_hrzntrue_abvblw){
        
        this.reDraw;
        this.points=multiArr_points_hrzntrue_abvblw[0];
        this.horizontalTrue=multiArr_points_hrzntrue_abvblw[1]
        this.aboveBelow=multiArr_points_hrzntrue_abvblw[2]
        
       
       
    }
    //used to move and redraw the hitbox - also changes the points array
        
        movement(points, lineWidth, gameObj,rotateAroundXIndex = 0, rotateAroundYIndex = 1,angle = 0 ){
       //used to temporarily store the x and y of a given point
           
        var xcoord;
        var ycoord;
        //used to check whether or not the part of the points array   you are iterating over is x or why
        var hasX=false;
       
        //interval to repeatedly redraw the hitbox
gameObj.hitbox.reDraw = setInterval(function(){
    ctx.save()

//Convert degrees to radian 
        var rad = (angle) * Math.PI / 180;

//Set the origin to the center of the image
    ctx.translate(points[rotateAroundXIndex],points[rotateAroundYIndex]);
      

//Rotate the canvas around the origin
        ctx.rotate(angle*Math.PI/180);
            ctx.beginPath();
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = lineWidth;
        ctx.moveTo(0,0);
       
      
        for (var i=0;i<points.length;i++){
           

            if (hasX==false){
                xcoord=points[i]-points[rotateAroundXIndex]
              
                //xcoord=points[i]
                hasX=true
            }else{
                ycoord=points[i]-points[rotateAroundYIndex]
                //ycoord=points[i]
                hasX=false
                
               
                ctx.lineTo(xcoord, ycoord)
                   
            }
            ////console.log(xcoord+", "+ycoord)
            
        
        
    }

        ctx.stroke();
     ctx.restore()
    }, 10)    
    
}
    endMovement(gameObj){
        clearInterval(gameObj.hitbox.reDraw)
     
    }

pointChange( points, x, y){
    
        var newX=true
       
   
        for( var j=0;j<points.length;j++){
           
            if(newX==true){
                
                points[j]+=x
                
                newX=false
            }else{
           
                points[j]+=y
                newX=true
            
            }   
            
            }   
      
        
        
    }
    
collisionDetect(hitbox, points, checkingX, checkingY, horizontalTrue, aboveBelow){
   //checks whether a given point is inside a hitbox, using the equation of each line(y=mx+c)
    var newX = true
    var firstPointCounter = true
    var point1X;
    var point1Y;
    var point2X;
    var point2Y;
    var gradient;
    var yIntercept;
    var lines = []
    var fitsAllCriteria  = true;


for( var k=0;k<points.length;k++){
    
            if(newX==true){
             if (firstPointCounter==true){
                point1X = points[k]
                
             }else{
                point2X = points[k]
                
             }  
          
               
                newX=false
            }else{
                if (firstPointCounter==true){
                    firstPointCounter = false
                point1Y = points[k]
             }else{
                point2Y = points[k]
                firstPointCounter = true
             }  
                newX=true
                
            }  
            
            if(k>2&&(k+1)%2==0){
            function stores( point1X, point1Y, point2X, point2Y){
                this.gradient=0.0
                this.yIntercept=0.0
               
                this.point2Y=point2Y
                this.point2X=point2X
                this.point1Y=point1Y
                this.point1X=point1X
            }
            lines.push(new stores( point1X, point1Y,point2X,point2Y))
           lines[Math.floor(k/2)-1].yIntercept=lines[Math.floor(k/2)-1].point1Y-(lines[Math.floor(k/2)-1].gradient*lines[Math.floor(k/4)].point1X)
            lines[Math.floor(k/2)-1].gradient=(point2Y-point1Y)/(point2X-point1X)

        
        
        }
           
    
        }
////console.log(points.length)
for( var k=0;k<points.length;k++){
////console.log(points.length)
       
          
            

            } 

            for(var l=0; l<horizontalTrue.length; l++){

                if (horizontalTrue[l]==2){
                    console.log("current item is horizontal")
                   // console.log(lines.length)
                    if(aboveBelow[l]==true){
                        
                        if(checkingY<points[2*l+1]){

                        } else{
                            console.log("failed")
                            fitsAllCriteria=false
                            console.log(checkingY)
                            console.log(points[2*l+1])
                        }
                    }else{
                     
                        if(checkingY>points[2*l+1]){
                           
                        }else{
                          
                          
                          
                          console.log("failed")
                            
                            fitsAllCriteria=false
                            
                        }
                      }
                }else if(horizontalTrue[l]==1){
                    console.log("current item is  vertical")
                    if(aboveBelow[l]==true){
                        console.log("point must be to the left of  line")
                        if(checkingX<points[2*l]){

                        }else{
                            console.log("failed")
                            fitsAllCriteria=false
                        }
                    }else{
                        console.log("point must be below line")
                        if(checkingX>points[2*l]){

                        } else{
                            console.log("failed")
                            fitsAllCriteria=false
                        }

                    }
                }else{
                    console.log("current item is diagonal")
                    if(aboveBelow[l]==true){
                        console.log("point must be above line")

                        if(((Math.max(checkingX, lines[l].point1X, lines[l].point2X)!=checkingX&&Math.min(checkingX, lines[l].point1X, lines[l].point2X)!=checkingX))){
                            
                            if(checkingY<((lines[l].gradient*checkingX)+lines[l].yIntercept||lines[l].gradient==Infinity)){

                            }else{
                            console.log("failed")
                            
                            console.log(lines[l].gradient)
                            console.log(lines[l].point1X)
                            console.log(lines[l].point2X)
                            console.log(lines[l].point1Y)
                            console.log(lines[l].point2Y)

                            fitsAllCriteria=false
                        }
                    
                    }
                        
                }else{ 
                    console.log("point must be below line")
                        if(((Math.max(checkingX, lines[l].point1X, lines[l].point2X)!=checkingX&&Math.min(checkingX, lines[l].point1X, lines[l].point2X)!=checkingX))){
                            console.log('hey')
                        if(checkingY>((lines[l].gradient*checkingX)+lines[l].yIntercept)||lines[l].gradient==Infinity){

                            }else{
                           
                           fitsAllCriteria=false
                         console.log("failed")


                        }
                    
                }
            }
                    
                
            
         
}



}
return fitsAllCriteria  
}




    
    
}
class gameObj{
    //used to store hitbox and gameObj in one place for simplicity
    constructor(hitbox, gamesprite){
        this.hitbox=hitbox
        this.gamesprite=gamesprite
        
    }
}
    //used to get dynamic styles, so that you dont hav e to define styles in css to access them in js
  var enemyStyle = getComputedStyle(enemy)
  var marioStyle = getComputedStyle(mario)
var enemyProjStyles = [getComputedStyle(enemyProjectile1), getComputedStyle(enemyProjectile2), getComputedStyle(enemyProjectile3), getComputedStyle(enemyProjectile4)]
enemy.style.left=enemyStyle.getPropertyValue("left")
enemy.style.top=enemyStyle.getPropertyValue("top")
mario.style.left = marioStyle.getPropertyValue("left")
mario.style.top = marioStyle.getPropertyValue("top")
    for (var m=0;m<enemyProjStyles.length;m++){
        //did the projectiles in a for loop bc im lazy
        eval("enemyProjectile"+(m+1)).style.left=enemyProjStyles[m].getPropertyValue("left")
        eval("enemyProjectile"+(m+1)).style.top=enemyProjStyles[m].getPropertyValue("top")
    }

//x and ys of main character
var marioPosArr = [19, 23,67,0,123,24,138, 46,120,77,67,67,23,80,-2, 46,  19,23]
//orientation of the lines of the hitbox, 0=diagonal, 1=vertical, 2=horizontal
var marioOrientationArr = [ 0,0 , 0, 0,0, 0 , 0,0 ]
//defines where a point must be to be within the hitbox, true is above a given line, false is below, (left/right respectively for vertical lines)
var marioContentsArr= [false, false, false, true, true, true, true, false]
var marioObj = new gameObj(new Hitbox(  ...[[...marioPosArr],[...marioOrientationArr],[...marioContentsArr]]),new GameSprite(50000, "mario", -1, 3,false,true, 250,  ...[...[71,6]]) )
x=new GameSprite()
var enemyProjectilePosArrays = [[3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0], [3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0], [3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0],[3,0,13,0,17,5,17,13,9,18,1,18,-2,13,-2,5,3,0]] 
var enemyProjectileOrientationArrays = [ [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0], [2,0, 1, 0, 2, 0, 1, 0]]
var enemyProjectileContentArrays = [false,false, true, true, true, true, false, false ]
//within gameSprite, the arguments are health, name, damage, type of damage, and damage that can be received
//gameObj for declaring the hitbox, gamesprite
var enemyProjectileObj1 = new gameObj(new Hitbox(...[[...enemyProjectilePosArrays[0]],[...enemyProjectileOrientationArrays[0]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile1", -10, 0,false, false, 0,  ...[...[]]))
var enemyProjectileObj2 = new gameObj(new Hitbox( ...[[...enemyProjectilePosArrays[1]],[...enemyProjectileOrientationArrays[1]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile2" , -10, 0,false, false, 0,  ...[...[]]))
var enemyProjectileObj3 = new gameObj(new Hitbox(...[[...enemyProjectilePosArrays[2]],[...enemyProjectileOrientationArrays[2]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile3", -10, 0,false, false, 0,   ...[...[]]))
var enemyProjectileObj4 = new gameObj(new Hitbox( ...[[...enemyProjectilePosArrays[3]],[...enemyProjectileOrientationArrays[3]] , [...enemyProjectileContentArrays]]), new GameSprite(1, "enemyProjectile4",-10, 0,false, false, 0, ...[...[]]))

var enemyPosArr = [309, 327, 390, 321, 456, 300, 522, 321, 549,  357, 522, 393, 456, 408, 390, 396, 309, 393, 291, 357, 309, 327]
var enemyOrientationArr = [0,0,0,0,0,0,0,0,0,  0]
var enemyContentsArr = [false, false, false, false, true, true, true, true, true, false]
var enemyObj = new gameObj(new Hitbox(...[[...enemyPosArr], [...enemyOrientationArr], [...enemyContentsArr]]), new GameSprite(100, "enemy", -1, 2, false, true, 250, ...[...[325, 333, 325, 384]]))


//starting all hitboxes
enemyProjectileObj1.hitbox.movement( enemyProjectilePosArrays[0], 1, enemyProjectileObj1)
enemyProjectileObj2.hitbox.movement(enemyProjectilePosArrays[1], 1,enemyProjectileObj2 )
enemyProjectileObj3.hitbox.movement( enemyProjectilePosArrays[2], 1, enemyProjectileObj3)
enemyProjectileObj4.hitbox.movement(enemyProjectilePosArrays[3], 1, enemyProjectileObj4)

marioObj.hitbox.movement(marioObj.hitbox.points, 1, marioObj)
enemyObj.hitbox.movement(enemyObj.hitbox.points, 1, enemyObj)
setTimeout(enemyObj.hitbox.pointChange, 1, enemyObj.hitbox.points, 5, 25)
function buttonControl(freq, btn, btnstring){
    //on mouse down , runs start move
    btn.addEventListener("mousedown", startMove);
    //start move creates work interval of move_m
    function startMove(){
        marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
    

   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
 
    xPara.innerHTML = Math.floor(mouseAngle)
        work = setInterval(function(){
            move_m(btnstring)
            
         
   
}, freq);
        
    }
    //on mouse up, runs end move
    btn.addEventListener("mouseup", endMove);
    //end move clears work interval
    function endMove(){
        clearInterval(work);
        
    }
    
}

//this is where the magic happens - used to move mari

function move_m(direction){
    var changer = 0;
    switch(direction){
   //if the direction is up
   case "up":
  
       //used to decide how much the value(top or left) is being changed by
       changer = -1;
      
       //checks if it is within limits
       if (playerBow.point2X<=0){
          
       }else{
           //actually changes value
           mario.style.top=Number(mario.style.top.substring(0, mario.style.top.length - 2))+changer+"px";
           marioObj.hitbox.endMovement(marioObj)
           marioObj.hitbox.pointChange(marioObj.hitbox.points,0,-1)
            marioObj.hitbox.movement(marioObj.hitbox.points, 1, marioObj)
            enemyMovement("left")
        
        }
      
       break;
       //direction is down
 
       case "down":
      
       changer = 1
      
       //see above for all of these
   if (Number(mario.style.top.substring(0, mario.style.top.length - 2))>=canvas.height){
   
       }else{
           mario.style.top=Number(mario.style.top.substring(0, mario.style.top.length - 2))+changer+"px";
           marioObj.hitbox.endMovement(marioObj)
           marioObj.hitbox.pointChange(marioObj.hitbox.points,0,1)
           marioObj.hitbox.movement( marioObj.hitbox.points, 1, marioObj)
           
        }
      
       break;
   case "left":
  
      if (Number(mario.style.left.substring(0, mario.style.left.length - 2))<=0){
          
       }else{
           mario.style.left=Number(mario.style.left.substring(0, mario.style.left.length - 2))-1+"px";
           marioObj.hitbox.endMovement(marioObj)
           
           marioObj.hitbox.pointChange(marioObj.hitbox.points,-1,0)
           marioObj.hitbox.movement( marioObj.hitbox.points, 1, marioObj)
           
           
        }
      
       break;
   case"right":
   
    if (Number(mario.style.left.substring(0, mario.style.left.length - 2))>=canvas.width){
       
       }else{
           mario.style.left=Number(mario.style.left.substring(0, mario.style.left.length - 2))+1+"px";
           marioObj.hitbox.endMovement(marioObj)
           marioObj.hitbox.pointChange(marioObj.hitbox.points,1,0)
           marioObj.hitbox.movement(enemyObj.hitbox.points,1, marioObj)
           
       }
      
       break;
   default:
}




    
}

// (canvas.style.left)
// moves enemy projectiles in the same fashion as the main character

   function enemyMovement(direction){
    var changer = 0;
    
 
    switch(direction){
   //if the direction is up
   case "up":
  
       //used to decide how much the value(top or left) is being changed by
       changer = -1;
      
       //checks if it is within limits
       if (Number(enemy.style.top.substring(0, enemy.style.top.length - 2))<=0){
     
       }else{
           //actually changes value
           playerBow.clearString(playerBow, friendlyArrow, friendlyArrow.gameObjArr.length-1)
            playerBow.bowMove(playerBow, 0, -1)
              
        }
      
       break;
       //direction is down
 
       case "down":
      
       changer = 1
      
       //see above for all of these
   if (Number(enemy.style.top.substring(0, enemy.style.top.length - 2))>=canvas.height){
   
       }else{
        playerBow.clearString(playerBow, friendlyArrow, friendlyArrow.gameObjArr.length-1)
            playerBow.bowMove(playerBow, 0, 1)
             
        }
      
       break;
   case "left":
  
      if (Number(enemy.style.left.substring(0, enemy.style.left.length - 2))<=0){
          
       }else{
        playerBow.clearString(playerBow, friendlyArrow, friendlyArrow.gameObjArr.length-1)
            playerBow.bowMove(playerBow, -1, 0)
             
           
        }
      
       break;
   case"right":
   
    if (Number(enemy.style.left.substring(0, enemy.style.left.length - 2))>=canvas.width){
       
       }else{
        playerBow.clearString(playerBow, friendlyArrow, friendlyArrow.gameObjArr.length-1)
            playerBow.bowMove(playerBow, 1,0)
           
       }
      
       break;
   default:
}
   }

var worker;
//used to check whether the key has already been pressed, to prevent the function from creating infinite intervals
var keyDownCheck;
//binding the keyboard rather than the buttons for movement
function keyControl(freq){
    //when any key is pressed down
    document.addEventListener("keydown", function(event) {
        //checks if keydown has already been called, without a keyup inbetween
        if (keyDownCheck==false){
             marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
             marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
             
            
        //checks the keycode of the pressed key
        switch (event.keyCode){
            
            case 87: 
            //w to move up
            worker = setInterval(function(){move_m("up")
            
        }, freq);
            
            
            break;
            case 83: 
            //s to move down
            
           worker = setInterval(function(){move_m("down")
         
         
    }, freq);
            break;
            case 68: 
            //d to move right
            
            worker = setInterval(function(){move_m("right")
            
        }, freq);
            
            
            break;
            case 65: 
            //a to move left
            
            worker = setInterval(function(){move_m("left")
           
        }, freq);
            break;
            default:
                
        }
    }
    //shows that key has been pressed down
    keyDownCheck=true;
    });
    
    

    document.addEventListener("keyup", function(event){
        //stops movement
        clearInterval(worker);
        //shows that key has been released
        keyDownCheck = false;
    });
}
//actually runs the function
keyControl(10);

//associates function with each button
//down
buttonControl(10, down, "down");
//left
buttonControl(10, left, "left");
//right
buttonControl(10, right, "right");
//up
buttonControl(10, up, "up");
function angleCalc(personX, personY, objX, objY){
    //finds the angle between points using trig function tan^-1
     width = personX-objX;
 
     height = personY-objY;
    var rawAngle = radiansToDegrees(Math.atan(height/width));
    if(width<0){
        rawAngle+=180
    }else if(height<0){
        rawAngle+=360

    }else if(height<0&&width<0){
        rawAngle+=270
    }
    return rawAngle

}
document.addEventListener("mousemove",function(event){
    //on mouse move it updates marioX and mouseAngle
     marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
   
   
   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
   
    
    xPara.innerHTML = mouseX
    yPara.innerHTML = mouseY
});

document.addEventListener("keydown", function(){
    marioX = Number(mario.style.left.substring(0, mario.style.left.length - 2));
     marioY = Number(mario.style.top.substring(0, mario.style.top.length - 2));
    //on kedown it updates marioX and mouseAngle

   //using trigenometry to figure out the angle between the player and the mouse
    mouseAngle = angleCalc(marioX, marioY, mouseX, mouseY);
   
   

});

function hitboxCollision(colliderObj, collideeObj){
    //creates a rectangle around a hitbox, and iterates over all the points within it. if any point is within both of the  hitboxes this function returns true, otherwise false
       var curX;
       var curY;
       var eeTrue=false
       var erTrue
       var collide=false
       var isX = true
       //gets the lowest and highest x and y in the hitbox
       var largeX=collideeObj.hitbox.points[0]
       var largeY=collideeObj.hitbox.points[1]
       var smolX=collideeObj.hitbox.points[0]
       var smolY=collideeObj.hitbox.points[1]
       
       for(var i = 0;i<collideeObj.hitbox.points.length;i++){
      
        if(isX){
            //x
            curX=collideeObj.hitbox.points[i]
            isX=false
        }else{
            //y
            curY=collideeObj.hitbox.points[i]
            isX=true
        }
       
        if(curX<smolX){
            
            smolX=curX
        }
        if(curY<smolY){
            smolY=curY
        }
        if(largeX<curX){
            largeX=curX
        }
        if(largeY<curY){
            largeY=curY
        }
        
    }/*
    //console.log(smolX)
    //console.log(smolY)
    //console.log(largeX)
    //console.log(largeY)
    */
   
 
    for(var n=smolX;n<largeX;n++){
        
        for(var o=smolY;o<largeY;o++){
            ////console.log(n+","+o)
      eeTrue=collideeObj.hitbox.collisionDetect(collideeObj.hitbox.points,n, o, collideeObj.hitbox.horizontalTrue, collideeObj.hitbox.aboveBelow)
           
      
        
      
       erTrue=colliderObj.hitbox.collisionDetect(colliderObj.hitbox.points, n, o, colliderObj.hitbox.horizontalTrue, colliderObj.hitbox.aboveBelow)
        
       if(eeTrue&&erTrue){
                collide=true
            }
        }
    }
    return collide;
    }


   

var collide;
var enemyDamage = setInterval(function(){
    //collide=hitboxCollision(enemyObj, enemyProjectileObj2)
    
    //console.log(collide)
    if(collide==true){
        //enemyObj.gamesprite.damageReceiver(enemyObj, enemyObj.gamesprite, enemyProjectileObj2.gamesprite, 50000, 50000)
       
    }
    //enemyObj.hitbox.movement(enemyObj.hitbox.points, 1)
    
    //console.log(enemyProjectileObj2.hitbox.collisionDetect(enemyProjectileObj2.hitbox.points, enemyProjectileObj2.hitbox.points[0]+5, enemyProjectileObj2.hitbox.points[1]+5, enemyProjectileObj2.hitbox.horizontalTrue, enemyProjectileObj2.hitbox.aboveBelow))
    //console.log(enemyProjectileObj2.hitbox.points[0]+5)
    //console.log(enemyProjectileObj2.hitbox.points[1]+5)
   
    
}, 500)

var aimingRadicalInterval;

var finalY;
var aimYIntercept;
var aimGradient;
var mouseDelay;
var mouseTrue=false;
    var oldX;
    var oldY;
    

function aimingRadical(gunX, gunY, followX, followY){
    //creates an animation that shows where projectiles will be shot

  
    
    oldX=eval(followX)
oldY=eval(followY)
  
    
     aimingRadicalInterval = setInterval(function(){
        if((eval(followY)-eval(gunY))/(eval(followX)-eval(gunX))!=Infinity){
        aimGradient = (eval(followY)-eval(gunY))/(eval(followX)-eval(gunX))
        }

aimYIntercept = eval(followY)-(aimGradient*eval(followX))
finalY=aimGradient*document.body.clientWidth+aimYIntercept


       
     //gCtx.clearRect(0,0,graphic.width, graphic.height)
       
     gCtx.beginPath()
     gCtx.strokeStyle = "#FFFFFF";
     gCtx.lineWidth = 15;
        gCtx.moveTo(eval(gunX)-2, eval(gunY))
        
        gCtx.lineTo(oldX,oldY-4)
        gCtx.stroke()
                    gCtx.closePath()
                    oldX=eval(followX)
oldY=eval(followY)
 
        gCtx.beginPath()
        gCtx.strokeStyle = "#000000";
        gCtx.lineWidth = 6;
        gCtx.moveTo(eval(gunX), eval(gunY))
        gCtx.lineTo(eval(followX), eval(followY)-3)
        gCtx.stroke()
        gCtx.closePath()
       
   
     }, 5)
    
     document.addEventListener("mousedown", function(event){
        //var a =performance.now()
       
        
if (eval(followX)>eval(gunX)&&eval(followX)>0&&mouseTrue==false&&event.button==0&&isMobile==false){
    mouseTrue=true 
    console.log("desktop shot")
    
marioObj.gamesprite.shoot(enemyProjectileObj2, eval(gunX), eval(gunY),  "document.body.clientWidth","finalY","marioObj.gamesprite.shotDelayToggle",window.innerWidth/4,  window.innerWidth)


setTimeout( function(){mouseTrue=false}, 500)

}

    
//var b=performance.now()
////console.log(b-a)
})

     
    
}
var infEnem=setInterval(enemyObj.gamesprite.respawn(300, 300, false, enemyObj, 10),10)
setTimeout(function(){
    if(isMobile==false){
    //aimingRadical("marioObj.hitbox.points[2]", "marioObj.hitbox.points[3]", "mouseX", "mouseY")
   
    }
}, 20)

//0.7 is easiest, 0 is hardest


var enem = new enemyAI(0.7)

//joystic

var joyBase;
var moveCentre;
class Joystick{
    constructor(joyX, joyY, name, leftBound, rightBound){
        this.joyX=joyX
        this.joyY=joyY
        this.innerX=joyX
        this.innerY=joyY
        this.convertX;
        this.convertY;
        this.name=name;
        this.withinBounds;
        this.leftBound=leftBound;
        this.rightBound=rightBound
        
    }
   
    moveJoy(joystick, x, y){
        joystick.joyX=x
        joystick.joyY=y
        joystick.innerX=x
        joystick.innerY=y
        
    }
    joyFollow(joystick, leftBound, rightBound, outColour, inColour){
       
        
               
                document.addEventListener("touchstart", (event)=>{
                 
 
           if(event.touches[0].clientX>leftBound&&event.touches[0].clientX<rightBound){
            joystick.joyX=event.touches[0].clientX
           joystick.joyY=event.touches[0].clientY
        
           }else{
           joystick.withinBounds=false
            //joystick.convertX=marioObj.hitbox.points[2]
            //joystick.convertY=marioObj.hitbox.points[3]
           
           }
  
    
})


       
        

                document.addEventListener("touchmove", (event) => {
                    if(event.touches[0].clientX>leftBound&&event.touches[0].clientX<rightBound){
                        joystick.withinBounds=true
                       // console.log("lol")
                    gCtx.beginPath()
                    gCtx.fillStyle = "#ffffff"
                    gCtx.arc(joystick.joyX, joystick.joyY, 52, 0, 2*Math.PI)
                    gCtx.fill()
                    gCtx.closePath()
           gCtx.beginPath()
    gCtx.fillStyle = outColour
    gCtx.arc(joystick.joyX, joystick.joyY, 50, 0, 2*Math.PI)
   
    gCtx.fill()
    gCtx.closePath()
                    }else{
                        joystick.withinBounds=false
                    }
})
       
      
        
            
            
                document.addEventListener("touchmove", (event) => {
                    if(event.touches[0].clientX>leftBound&&event.touches[0].clientX<rightBound){
                        joystick.withinBounds=true
                    //console.log("lol")
                    gCtx.beginPath()
                    gCtx.fillStyle = "#ffffff"
                    gCtx.arc(joystick.innerX, joystick.innerY, 27, 0, 2*Math.PI)
                    gCtx.fill()
                    gCtx.closePath()
                gCtx.beginPath()
    gCtx.fillStyle = "#0381fc"
    if(event.touches[0].clientX>joystick.joyX-50&&event.touches[0].clientX<joystick.joyX+50&&event.touches[0].clientY>joystick.joyY-50&&event.touches[0].clientY<joystick.joyY+50){
        gCtx.arc(event.touches[0].clientX, event.touches[0].clientY, 25, 0, 2*Math.PI)
        joystick.innerX=event.touches[0].clientX
    joystick.innerY=event.touches[0].clientY
    }else if(event.touches[0].clientX>joystick.joyX-100&&event.touches[0].clientX<joystick.joyX+100&&event.touches[0].clientY>joystick.joyY-100&&event.touches[0].clientY<joystick.joyY+100){
       
        var accDist = Math.sqrt(Math.pow(event.touches[0].clientX-joystick.joyX, 2) + Math.pow(event.touches[0].clientY-joystick.joyY, 2))
        var scaleFac = accDist/50
       
      
        var adjX = joystick.joyX+((event.touches[0].clientX-joystick.joyX)/scaleFac)
        var adjY = joystick.joyY+((event.touches[0].clientY-joystick.joyY)/scaleFac)
        gCtx.arc(adjX, adjY, 25, 0, 2*Math.PI)
       gCtx.closePath()
       
        joystick.innerX=adjX
    joystick.innerY=adjY
    
    }

    }else{
                        joystick.withinBounds=false
                    }
  
   
    gCtx.fill()
    gCtx.closePath()
  
   

})
          
           
       
        
        

    }
    joyBind(funcString, joystick, joyName){

     eval(funcString+"(joystick, joyName)")
        
    
    }
    
    
}
var moveJoystick = new Joystick(250, 250, "moveJoystick", 0, window.innerWidth/2)
var shotJoystick = new Joystick(canvas.width-250, canvas.height-250, "shotJoystick", window.innerWidth/2, window.innerWidth)
var backY;
var forwardShot;
function shotBind(joystick, joyName){
    
    setInterval(function(){
        var xOffset= joystick.innerX-joystick.joyX
        var yOffset = joystick.innerY-joystick.joyY
       

        
        xOffset*=4.5
        yOffset*=4.5
        joystick.convertX=xOffset+playerBow.point3X
        joystick.convertY = yOffset+playerBow.point3Y
       
       
        
     
        

    //console.log(finalY)
        }, 5)
     
        document.addEventListener("touchend", (event)=>{
           
            if(joystick.withinBounds==true){   
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
            clearInterval(moveCentre)
            //console.log(moveCentre)
            clearInterval(joyBase)
            gCtx.beginPath()
                    gCtx.fillStyle = "#ffffff"
                    gCtx.arc(joystick.joyX, joystick.joyY, 75, 0, 2*Math.PI)
                    gCtx.fill()
                    gCtx.closePath()
                    if(mouseTrue==false){
                   
                            marioObj.gamesprite.shoot(enemyProjectileObj2, "playerBow.point3X", "playerBow.point3Y",  "document.body.clientWidth","finalY","marioObj.gamesprite.shotDelayToggle",window.innerWidth,  window.innerWidth)
                      
                    
                    mouseTrue=true
                    }
                    setTimeout( function(){mouseTrue=false}, 100)
                }
                
        })
    
        setTimeout(aimingRadical, 6, "playerBow.point3X", "playerBow.point3Y", joyName+".convertX", joyName+".convertY")
        //aimingRadical("marioObj.hitbox.points[2]", "marioObj.hitbox.points[3]", joyName+".convertX", joyName+".convertY")
    
}
function moveBind(joystick, joyName){
    var firstTime = 0
    function mover(){
        var xOffset= joystick.innerX-joystick.joyX
        var yOffset = joystick.innerY-joystick.joyY
       

        
        xOffset/=20
        yOffset/=20
        if(marioObj.hitbox.points[2]<window.innerWidth/2||xOffset<=0){
        marioObj.hitbox.pointChange(marioObj.hitbox.points, xOffset, yOffset)
        mario.style.top=Number(mario.style.top.substring(0, mario.style.top.length - 2))+yOffset+"px"
        mario.style.left=Number(mario.style.left.substring(0, mario.style.left.length - 2))+xOffset+"px"
        }
    }
 var storedThing = setInterval(mover, 10)
document.addEventListener("touchend", (event)=>{
    clearInterval(storedThing)
})
document.addEventListener("touchstart", (event)=>{
    if(event.touches[0].clientX>joystick.leftBound&&event.touches[0].clientX<joystick.rightBound&&firstTime!=0){
        storedThing = setInterval(mover, 10)
        
        
    }else{
        firstTime++
    }
})
}
if(isMobile==true){
    
    shotJoystick.joyFollow(shotJoystick, shotJoystick.leftBound, shotJoystick.rightBound, "#8dc5fc", "#0381fc")
    shotJoystick.moveJoy(shotJoystick, shotJoystick.joyX, shotJoystick.joyY)
    shotJoystick.joyBind("shotBind", shotJoystick, "shotJoystick")
    moveJoystick.joyFollow(moveJoystick, moveJoystick.leftBound, moveJoystick.rightBound, "#723a03","#fc7e03" )
    moveJoystick.moveJoy(moveJoystick, moveJoystick.joyX,moveJoystick.joyY )
    moveJoystick.joyBind("moveBind", moveJoystick, "moveJoystick")
    
    
} 

function healthBar(obj, healthX, healthY, colour ){
    var healthBarRatio=obj.gamesprite.health/obj.gamesprite.maxHealth
    setInterval(function(){
        healthBarRatio=obj.gamesprite.health/obj.gamesprite.maxHealth
       
        
        if(healthBarRatio>0){
            gCtx.fillStyle=colour
            gCtx.beginPath()
            gCtx.arc(healthX+20, healthY+12.5, 6.5, Math.PI/2,  1.5*Math.PI, false)
            gCtx.fill()
            gCtx.closePath()
            gCtx.beginPath()
           gCtx.fillRect(healthX+20, healthY+5, healthBarRatio*60, 15)
           gCtx.closePath()
           gCtx.beginPath()
           if(healthBarRatio>=0.9){
           gCtx.arc(healthX+80, healthY+12.5, 6.5, Math.PI/2,  1.5*Math.PI, true)  
           }
           gCtx.fill()
           gCtx.closePath()
        }
       
        gCtx.strokeStyle="#000000"
        gCtx.lineWidth=1
    gCtx.beginPath()
    
    gCtx.moveTo(healthX+20, healthY+5)
    gCtx.lineTo(healthX+80, healthY+5)
    gCtx.moveTo(healthX+80, healthY+20)
    gCtx.lineTo(healthX+20, healthY+20)
    gCtx.moveTo(healthX+20, healthY+5)
    gCtx.stroke()
   gCtx.closePath()
   gCtx.beginPath()

    gCtx.arc(healthX+20, healthY+12.5, 7.5, Math.PI/2,  1.5*Math.PI, false)
    
    gCtx.stroke()
    gCtx.closePath()
    gCtx.beginPath()
    gCtx.arc(healthX+80, healthY+12.5, 7.5, Math.PI/2, 1.5*Math.PI, true)
    
    gCtx.stroke()
    gCtx.closePath()
    }, 10)
   
    
}
healthBar(marioObj, 0,0, "#00FF00")
healthBar(enemyObj, window.innerWidth-100, 0, "#FF0000")

class Bow{
    constructor(point1X, point2X, point3X, point4X, point1Y, point2Y, point3Y, point4Y, ...colourArr){
        this.point1X=point1X
        this.point2X=point2X
        this.point3X=point3X
        this.point4X=point4X
        this.point1Y=point1Y
        this.point2Y=point2Y
        this.point3Y=point3Y
        this.point4Y=point4Y
        this.colourArr=colourArr[0]
        this.verticalHeight = point4Y-point2Y-14
        this.rotInt;
        this.oYDiff
        this.oXDiff
        this.idealX = point3X+150
        this.idealY = point3Y
        this.arrowCount = 0
        this.gameObj
        this.bowImg
        this.drawInt
        this.drawAngle = 0
      

    }
    clearString(bow, arrow){
        
            gCtx.fillStyle = "#FFFFFF" 
            arrow.endArrowDraw(arrow, arrow.gameObjArr.length-1)
            
            gCtx.clearRect(bow.point1X, bow.point2Y, (bow.point2X-bow.point1X)+7, bow.verticalHeight+15)   
            
            
    }
 
    drawBow(bow){
        var verticalHeight=bow.point4Y-bow.point2Y-14
        var bodyWidth=bow.point4X-bow.point2X
        var px1=1/verticalHeight+verticalHeight
        var py1=((1/42)*verticalHeight)+verticalHeight
        var relSize=((1/42)*verticalHeight)
       
        bow.drawInt=setInterval(function(){

              gCtx.clearRect(bow.point1X-bow.verticalHeight/2-10, bow.point2Y, bow.verticalHeight+23, bow.verticalHeight+23)
            gCtx.save()
       gCtx.translate(bow.point1X, bow.point1Y)
       gCtx.rotate(bow.drawAngle*Math.PI/180)

            px1=((1/42)*verticalHeight)+bow.point2X
            py1=((1/42)*verticalHeight)+bow.point2Y
            px1-=bow.point1X
            py1-=bow.point1Y
            //top part of the bow's body
        gCtx.lineWidth = 1
        gCtx.fillStyle=bow.colourArr[0]
        gCtx.fillRect(px1, py1, 2*relSize, 2*relSize)
        px1+=((1/42)*verticalHeight)
        py1+=2*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[1]
        gCtx.fillRect(px1, py1, 3*relSize,2*relSize )
        px1+=((1/42)*verticalHeight)
        py1+=2*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[2]
        gCtx.fillRect(px1, py1, 3*relSize,4*relSize )
        px1+=((1/42)*verticalHeight)
        py1+=4*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[3]
        gCtx.fillRect(px1, py1, 3*relSize, 4*relSize)
        px1+=((1/42)*verticalHeight)
        py1+=4*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[4]
        gCtx.fillRect(px1, py1, 3*relSize, 4*relSize)
        px1+=((1/42)*verticalHeight)
        py1+=4*((1/42)*verticalHeight)
   
        gCtx.fillStyle=bow.colourArr[5]
        gCtx.fillRect(px1, py1, 3*relSize, 5*relSize)
            //bottom part of the bows body
        px1=((1/42)*verticalHeight)+bow.point2X
            py1=((1/42)*verticalHeight)+bow.point2Y
       px1-=bow.point1X
            py1-=bow.point1Y
            py1+=((1/42)*verticalHeight)*42
        gCtx.fillStyle=bow.colourArr[0]
        gCtx.fillRect(px1, py1, 2*relSize, 2*relSize)
        px1+=((1/42)*verticalHeight)
        py1-=2*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[1]
        gCtx.fillRect(px1, py1, 3*relSize,2*relSize )
        px1+=((1/42)*verticalHeight)
        py1-=4*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[2]
        gCtx.fillRect(px1, py1, 3*relSize,4*relSize )
        px1+=((1/42)*verticalHeight)
        py1-=4*((1/42)*verticalHeight)
  
        gCtx.fillStyle=bow.colourArr[3]
        gCtx.fillRect(px1, py1, 3*relSize, 4*relSize)
        px1+=((1/42)*verticalHeight)
        py1-=4*((1/42)*verticalHeight)

        gCtx.fillStyle=bow.colourArr[4]
        gCtx.fillRect(px1, py1, 3*relSize, 4*relSize)
        px1+=((1/42)*verticalHeight)
        py1-=4*((1/42)*verticalHeight)
 
        gCtx.fillStyle=bow.colourArr[5]
     
        gCtx.fillRect(px1, py1, 3*relSize, 5*relSize)
        //string
        gCtx.strokeStyle=bow.colourArr[6]
      
        gCtx.moveTo(bow.point2X+7-bow.point1X , bow.point2Y+((1/28)*verticalHeight)-bow.point1Y )
        gCtx.lineTo(7, 1)
        gCtx.lineTo(bow.point4X+7-bow.point1X, bow.point4Y-bow.point1Y)
        gCtx.stroke()
      gCtx.restore()
        }, 10)

     
    }
    aimBow(bow, arrow){
       var aimer =  setInterval(function(){
        bow.clearString(bow, arrow, arrow.length-1)
        bow.point1X-=4
       
           
        }, 5)
        setTimeout(clearInterval, 200, aimer)
    }
    releaseBow(bow, arrow){
       var  releaser = setInterval(function(){
           
        gCtx.fillStyle = "#FFFFFF"
           
            
            bow.point1X+=14
            
        }, 5)
        setTimeout(clearInterval, 50, releaser)
        
    }
    bowBind(func){
        eval(func)
    }
    bowMove(bow, x, y){
      
        bow.point1X+=x
        bow.point2X+=x
        bow.point3X+=x
        bow.point4X+=x
       
        bow.point1Y+=y
        bow.point2Y+=y
        bow.point3Y+=y
        bow.point4Y+=y
        bow.gameObj.hitbox.endMovement(bow.gameObj)
       bow.gameObj.hitbox.pointChange(bow.gameObj.hitbox.points, x, y)
       bow.gameObj.hitbox.movement(bow.gameObj.hitbox.points, 1, bow.gameObj, 14, 15, bow.drawAngle)

  
    }
    
    bowGameObj(bow, bowName){

   //defines where a point must be to be within the hitbox, true is above a given line, false is below, (left/right respectively for vertical lines)

    var bowPointsArray = [ 603,152,633, 152,  673, 232, 673, 387, 634,467, 604, 467, 520, 327, 520, 297, 603,152]
    var bowOrientationArray = [2,0,1,0, 2, 0, 1, 0]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
    var bowContentsArray = [false, false, true ,true, true, true, false, false]



    class style{
        constructor(left, right){
            this.left=left
            this.right=right
        }
    }
    class bowImg{
        constructor(style){
            this.style=style
        }
    }
    var bowStyle = new style(String(bow.point3X)+"px", String(bow.point3Y)+"px")
    var bowImage = new bowImg(bowStyle)
    bow.bowImg = bowImage

//within gameSprite, the arguments are health, name, damage, type of damage, and damage that can be received
//gameObj for declaring the hitbox, gamesprite
bow.gameObj = new gameObj(new Hitbox( ...[[...bowPointsArray],[...bowOrientationArray] , [...bowContentsArray]]), new GameSprite(1, bowName, -10, 0,false, false, 0,  ...[...[]]))





    }



}


playerColourArr = ["#000000","#000000","#000000","#000000","#000000", "#000000"]
var playerBow = new Bow(600,  600, 670,600, 308.5, 150, 314,450, [...playerColourArr] )
playerBow.bowGameObj(playerBow, "playerBow")
playerBow.gameObj.hitbox.movement(playerBow.gameObj.hitbox.points, 1, playerBow.gameObj)
console.log(playerBow.drawAngle)




var arrowGameObjArr;
var arrowImgArr
//setTimeout(playerBow.releaseBow, 250, playerBow)
class ArrowInit{
    constructor(width1, width2, width3, point1X, point1Y, point2X, point2Y){
        this.width1=width1
        this.width2=width2
        this.width3=width3
        this.points = []
        this.gradient;
        this.yIntercept;
        this.point1X=point1X
        this.point2X=point2X
        this.point1Y=point1Y
        this.point2Y=point2Y
        this.totalLength=this.point2X-this.point1X
        this.identifier;
        this.gameObjArr = []
        this.imageArr =  []
        this.drawArr = [[]]
        
        
    }
    drawArrow(arrow, arrowIndex, angle){
        var totalLength = arrow.point2X-arrow.point1X
      
        var currXOffset = arrow.gameObjArr[arrowIndex].hitbox.points[0]-534
        console.log(angle+" "+arrowIndex)
       function fletchlingDraw(){
        
        
            
        gCtx.save()

//Convert degrees to radian 
        var rad = (angle) * Math.PI / 180;

//Set the origin to the center of the image
       gCtx.translate(arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[1]);
      
   
//Rotate the canvas around the origin
        gCtx.rotate(angle*Math.PI/180);
        
            gCtx.clearRect(-10,-15,250,25)  
       
    
     
     
// Restore canvas state as saved from above
    
        arrow.gradient = (arrow.point2Y-arrow.point1Y)/(arrow.point2X-arrow.point1X)

        arrow.yIntercept = arrow.point1Y-(arrow.gradient*arrow.point1X)
        gCtx.lineWidth = 1
        //back of arrow

    
        //back of arrow
        gCtx.beginPath()
        gCtx.lineTo(0, 0)
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[2]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[3]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[4]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[5]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        //line1
    
        //console.log(arrow.gameObjArr[arrowIndex].hitbox.points[4])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[6]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[7]+2-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[8]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[9]+2-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[10]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[11]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
   
      
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[12]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[13]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
       gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[14]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[15]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
   
    
        //front of arrow
      
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[16]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[17]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[18]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[19]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[20]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[21]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[22]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[23]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[24]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[25]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[26]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[27]-arrow.gameObjArr[arrowIndex].hitbox.points[1])
        gCtx.lineTo(arrow.gameObjArr[arrowIndex].hitbox.points[28]-arrow.gameObjArr[arrowIndex].hitbox.points[0], arrow.gameObjArr[arrowIndex].hitbox.points[29]-arrow.gameObjArr[arrowIndex].hitbox.points[1])

        gCtx.stroke()
        gCtx.closePath()
    // body of arrow


        gCtx.restore();
        }
        
        var draw = setInterval(function(){
            fletchlingDraw()
        }, 10)
        arrow.drawArr[arrowIndex].push(draw) 
        
    }
    deleteArrow(arrow, arrowIndex, bow){
        arrow.endArrowDraw(arrow, arrowIndex)
        arrow.gameObjArr[arrowIndex].hitbox.endMovement(arrow.gameObjArr[arrowIndex])
        arrow.gameObjArr[arrowIndex] = null
        
    }
    endArrowDraw(arrow, arrowIndex, angle = 0){

        //console.log(arrow.drawArr[arrowIndex][0])
        var currXOffset = arrow.gameObjArr[arrowIndex].hitbox.points[0]-534
        var currYOffset = arrow.gameObjArr[arrowIndex].hitbox.points[1]-314
        
            clearInterval(arrow.drawArr[arrowIndex][0])
            gCtx.save()

//Convert degrees to radian 
        var rad = (angle) * Math.PI / 180;

//Set the origin to the center of the image
       gCtx.translate(arrow.point1X-65+currXOffset-6, arrow.point1Y+10+currYOffset-12);
      
   
//Rotate the canvas around the origin
        gCtx.rotate(angle*Math.PI/180);

      
        arrow.drawArr[arrowIndex].splice(0, arrow.drawArr[arrowIndex].length)
     
        var currXOffset = arrow.gameObjArr[arrowIndex].hitbox.points[0]-534
        var currYOffset = arrow.gameObjArr[arrowIndex].hitbox.points[1]-314
  
        gCtx.clearRect(-(arrow.totalLength*(arrow.width1+arrow.width2+arrow.width3)+65)/2-100, -(arrow.totalLength*(arrow.width1+arrow.width2+arrow.width3)+65)/2-100,(arrow.totalLength*(arrow.width1+arrow.width2+arrow.width3)+65)*2, (arrow.totalLength*(arrow.width1+arrow.width2+arrow.width3)+80)*2 )
       gCtx.restore()
    }
    

    arrowGameObj(arrow,  bow){
   bow.arrowCount+=1 

   //defines where a point must be to be within the hitbox, true is above a given line, false is below, (left/right respectively for vertical lines)
    var arrowPointsArray = [534 ,314, 528, 302, 560, 302, 567, 307/*end of top of first arrow fletchlincg*/,710, 307, 705, 300, 739, 300, 748, 310, 740, 322, 705, 322, 710,  313,/*end of  secondfletchlincg*/ 567, 313, 560, 322, 528, 322, 534, 314]
    var arrowOrientationArray = [0, 2, 0, 2, 0,2, 0, 0, 2, 0, 2, 0,2, 0]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
    var arrowContentsArray = [true, false, false,false,true, false, false, true, true, false, true, true, true, false    ]                        



    class style{
        constructor(left, right){
            this.left=left
            this.right=right
        }
    }
    class arrowImg{
        constructor(style){
            this.style=style
        }
    }
    var arrowStyle = new style(String(bow.point3X)+"px", String(bow.point3Y)+"px")
    var arrowImage = new arrowImg(arrowStyle)

//within gameSprite, the arguments are health, name, damage, type of damage, and damage that can be received

//gameObj for declaring the hitbox, gamesprite
var arrowgameObj = new gameObj(new Hitbox(...[[...arrowPointsArray],[...arrowOrientationArray] , [...arrowContentsArray]]), new GameSprite(1, "", -10, 0,false, false, 0,  ...[...[]]))
 eval(arrow.gameObjArr.push(arrowgameObj))
 eval(arrow.imageArr.push(arrowImage))

 arrow.gameObjArr[arrow.gameObjArr.length-1].gamesprite.name = arrow.imageArr[arrow.imageArr.length-1]

arrow.gameObjArr[arrow.gameObjArr.length-1].hitbox.movement(arrow.gameObjArr[arrow.gameObjArr.length-1].hitbox.points, 1, arrow.gameObjArr[arrow.gameObjArr.length-1])
    }
    shootArrow(arrow, arrowIndex, targetX, targetY, bow, projSpeed){
        var internalAngle= angleCalc(bow.point3X, bow.point3Y, targetX, targetY)-187

        var totalDist = Math.sqrt(Math.pow(arrow.gameObjArr[arrowIndex].hitbox.points[0]-targetX, 2)+Math.pow(arrow.gameObjArr[arrowIndex].hitbox.points[1]-targetY, 2))
        var relFreq = (arrow.gameObjArr[arrowIndex].hitbox.points[0]-targetX)/(arrow.gameObjArr[arrowIndex].hitbox.points[1]-targetY)
        var yCheck
     

        if((arrow.gameObjArr[arrowIndex].hitbox.points[1]-targetY)>0){
            yCheck=-1
        }else{
            yCheck=1
        }
  
        if(projSpeed<1){
            projSpeed=1
        } 
        arrow.endArrowDraw(arrow, arrowIndex)
    
         arrow.drawArrow(arrow, arrowIndex, internalAngle)

        var shootInterval = setInterval(function(){
             //arrow.endArrowDraw(arrow, arrowIndex, 10)
         
        


        
            arrow.gameObjArr[arrowIndex].hitbox.endMovement(arrow.gameObjArr[arrowIndex])
           
            arrow.gameObjArr[arrowIndex].hitbox.pointChange(arrow.gameObjArr[arrowIndex].hitbox.points,relFreq, yCheck )
            arrow.gameObjArr[arrowIndex].hitbox.movement( arrow.gameObjArr[arrowIndex].hitbox.points, 1,  arrow.gameObjArr[arrowIndex],undefined, undefined, internalAngle)
            
          
           //console.log(arrow.gameObjArr[arrowIndex].hitbox.points[0])
           //console.log(arrow.gameObjArr[arrowIndex].hitbox.points[1])
         
        }, 10)
        setTimeout(function(){
            clearInterval(shootInterval)
            arrow.endArrowDraw(arrow, 0)
        }, totalDist/projSpeed*1000)

    }
    
}
var friendlyArrow = new ArrowInit(1/6, 2/3, 1/6, 600, 300, 780, 300)
friendlyArrow.arrowGameObj(friendlyArrow, playerBow)
friendlyArrow.drawArrow(friendlyArrow,0, 0)







playerBow.drawBow(playerBow)
//playerBow.aimBow(playerBow, friendlyArrow)
friendlyArrow.shootArrow(friendlyArrow, 0,1000, 500, playerBow, 100)

class Player{
    constructor(x, y,colour1, colour2 = "", colour3 = "", colour4 = "", colour5 = "" ){
        this.x = x
        this.y = y
        this.colour1 = colour1
        this.colour2 = colour2
        this.colour3 = colour3
        this.colour4 = colour4
        this.colour5 = colour5
        this.drawAngle = 0
        this.drawInt;

    }
    drawPlayer(player){
        
        player.drawInt = setInterval(function(){
        gCtx.save()
        gCtx.translate(player.x, player.y)
        gCtx.rotate(player.drawAngle*Math.PI/180)
        var len = 37/7
        var offsetStore = 0
        gCtx.fillStyle = player.colour1
            //outside layer
        gCtx.fillRect(2*len, 0*len, 2*len, 9*len)
        offsetStore+=4*len
        gCtx.fillRect(0, offsetStore+3*len, 2*len, 8*len)
         offsetStore+=8*len
        gCtx.fillRect(2*len, offsetStore+3*len, len, 2*len)
         offsetStore+=2*len
         gCtx.fillRect(3*len, offsetStore+2*len, len, len)
         offsetStore+=2*len    
         gCtx.fillRect(4*len, offsetStore+len, 2*len, 2*len)
        
              gCtx.fillRect(6*len, offsetStore+len, len, len)
              offsetStore+=3*len
             gCtx.fillRect(len, offsetStore, 3*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(4*len, offsetStore, 2*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(6*len, offsetStore, 6*len, 2*len)
         offsetStore+=2*len
        gCtx.fillRect(10*len, offsetStore-4*len, 2*len, 2*len)
         gCtx.fillRect(11*len, offsetStore-5*len, len, len)
        gCtx.fillRect(12*len, offsetStore-len, len, 3*len)
         offsetStore+=len
           gCtx.fillRect(13*len, offsetStore, len, len)
           offsetStore+=len
           gCtx.fillRect(14*len, offsetStore, 8*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(22*len, offsetStore-4*len, len, len)
         offsetStore-=2*len
         gCtx.fillRect(20*len, offsetStore-len, 3*len, len)
      
         gCtx.fillRect(22*len, offsetStore-2*len, 2*len, len)
         offsetStore-=3*len
         //centrepiece
         gCtx.fillRect(24*len, offsetStore-9*len, 3*len, 11*len)
         offsetStore-=13*len
         //returning to 0,0
         gCtx.fillRect(22*len, offsetStore, 2*len, 4*len)
         offsetStore-=4*len
          gCtx.fillRect(20*len, offsetStore, 2*len, 4*len)
         offsetStore-=2*len
         gCtx.fillRect(16*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
            gCtx.fillRect(12*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
            gCtx.fillRect(8*len, offsetStore, 4*len, 2*len)
         offsetStore-=1*len
            gCtx.fillRect(4*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
         //right wing
         gCtx.restore()
  
gCtx.save()
len = 37/7
    //gCtx.translate(0,graphic.height); 
    gCtx.scale(-1,1)
    
    gCtx.fillStyle=player.colour1
    gCtx.translate(player.x-120*len, player.y)

    //gCtx.rotate(Math.PI)
            //gCtx.translate(-52*len, -56*len)

        offsetStore = 0
        gCtx.fillStyle = player.colour1
            //outside layer
        gCtx.fillRect(2*len, 0*len, 2*len, 9*len)
        offsetStore+=4*len
        gCtx.fillRect(0, offsetStore+3*len, 2*len, 8*len)
         offsetStore+=8*len
        gCtx.fillRect(2*len, offsetStore+3*len, len, 2*len)
         offsetStore+=2*len
         gCtx.fillRect(3*len, offsetStore+2*len, len, len)
         offsetStore+=2*len    
         gCtx.fillRect(4*len, offsetStore+len, 2*len, 2*len)
        
              gCtx.fillRect(6*len, offsetStore+len, len, len)
              offsetStore+=3*len
             gCtx.fillRect(len, offsetStore, 3*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(4*len, offsetStore, 2*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(6*len, offsetStore, 6*len, 2*len)
         offsetStore+=2*len
        gCtx.fillRect(10*len, offsetStore-4*len, 2*len, 2*len)
         gCtx.fillRect(11*len, offsetStore-5*len, len, len)
        gCtx.fillRect(12*len, offsetStore-len, len, 3*len)
         offsetStore+=len
           gCtx.fillRect(13*len, offsetStore, len, len)
           offsetStore+=len
           gCtx.fillRect(14*len, offsetStore, 8*len, 2*len)
         offsetStore+=2*len
           gCtx.fillRect(22*len, offsetStore-4*len, len, len)
         offsetStore-=2*len
         gCtx.fillRect(20*len, offsetStore-len, 3*len, len)
      
         gCtx.fillRect(22*len, offsetStore-2*len, 2*len, len)
         offsetStore-=3*len
         //centrepiece
         gCtx.fillRect(24*len, offsetStore-9*len, 3*len, 11*len)
         offsetStore-=13*len
         //returning to 0,0
         gCtx.fillRect(22*len, offsetStore, 2*len, 4*len)
         offsetStore-=4*len
          gCtx.fillRect(20*len, offsetStore, 2*len, 4*len)
         offsetStore-=2*len
         gCtx.fillRect(16*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
            gCtx.fillRect(12*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
            gCtx.fillRect(8*len, offsetStore, 4*len, 2*len)
         offsetStore-=1*len
            gCtx.fillRect(4*len, offsetStore, 4*len, 2*len)
         offsetStore-=2*len
         gCtx.restore()
 
         
         gCtx.save()
    
    gCtx.translate(player.x, player.y)
    gCtx.rotate(player.drawAngle*Math.PI/180)
    //centre part of each wing
 
   
    gCtx.fillStyle = player.colour1
   
    len = 37/7
    offsetStore = 0

    gCtx.translate(12*len, 16*len)
    gCtx.fillRect(0,len, 2*len, 2*len)
   
    gCtx.fillRect(len, 0, 7*len, len)


    gCtx.fillRect(2*len, offsetStore+len, len, len)
   
    gCtx.fillRect(7*len,offsetStore+2*len, len,-len )
    gCtx.fillRect(8*len, offsetStore+len, len, 3*len)
    offsetStore+=4*len
    gCtx.fillRect(7*len, offsetStore, len, 2*len)
    //right wing
    gCtx.restore()
    gCtx.save()

    gCtx.scale(-1,1)
    
    gCtx.fillStyle=player.colour1
    gCtx.translate(-player.x-38*len,player.y+16*len)
//gCtx.fillRect(0,0,600,600)
    //gCtx.rotate(Math.PI)
    offsetStore=0
    len=37/7
    gCtx.fillRect(0,len, 2*len, 2*len)
   
    gCtx.fillRect(len, 0, 7*len, len)


    gCtx.fillRect(2*len, offsetStore+len, len, len)
   
    gCtx.fillRect(7*len,offsetStore+2*len, len,-len )
    gCtx.fillRect(8*len, offsetStore+len, len, 3*len)
    offsetStore+=4*len
    gCtx.fillRect(7*len, offsetStore, len, 2*len)
    gCtx.restore()

   gCtx.save()
    //2nd layer
    offsetStore = 0
    len=37/7
    gCtx.fillStyle = player.colour2
    gCtx.translate(player.x+2*len, player.y+2*len)
    gCtx.fillRect(2*len,0,len,7*len )
    offsetStore+=7*len
    gCtx.fillRect(0,offsetStore, 2*len, 6*len)
    offsetStore+=6*len
    gCtx.fillRect(len, offsetStore, 2*len, len)
    offsetStore+=len
    gCtx.fillRect(2*len, offsetStore, 4*len, len)
    offsetStore+=len
    gCtx.fillRect(5*len, offsetStore, len, 2*len)
    offsetStore+=len
    gCtx.fillRect(4*len, offsetStore, 2*len, len)
    offsetStore+=len
    gCtx.fillRect(2*len,offsetStore, 2*len, 3*len )
    offsetStore+=len
    gCtx.fillRect(5*len, offsetStore, len, len)
    offsetStore+=len
    gCtx.fillRect(4*len, offsetStore, 4*len, 2*len)

    gCtx.restore()
        },10)

     
        
    }
}
var p1 = new Player(270,100,"#FFFF66")
p1.drawPlayer(p1)
//END OF JS CODE HERE  
});

 

    

        </script>
    </head>
    <body id="body">
        
       <canvas id="graphicCanvas" ></canvas>
        <img src = "https://i.ibb.co/3cdyx1Y/d-sub-pixilart-3.jpg" alt = "its a me a" id  =  "mario">
        <img src="https://i.ibb.co/M5m4Jpn/pixilart-drawing-1.png" alt="enemy" id="enemy">
      
       
<p>is a problem with calculating the y intercept in hitboxCOllision function. still havent fixed line 758 </p>
<p id="mousex">hello</p>
<p id = "mousey">l</p>
<canvas id="devCanvas"style = "   left: 0px; top: 0px;"  ></canvas>
<img  id = "enemyProjectile1"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile2"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile3"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<img   id = "enemyProjectile4"src="https://i.ibb.co/G354M3H/pixil-frame-0-1-2.jpg" alt="enemyProjectile" border="0">
<button id="up">up</button>
<button id = "down">down</button>
<button id = "right">right</button>
<button id ="left">left</button>
<div id = "start">


</div>
<div id="end">


</div>


    </body>

</html>